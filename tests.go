// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "sdk/internal"
	time "time"
)

type CreateTestRequest struct {
	// The name of the test.
	Name string `json:"name" url:"name"`
	// The request object for the test.
	Request map[string]interface{} `json:"request,omitempty" url:"request,omitempty"`
	// The expected response object for the test.
	Response map[string]interface{} `json:"response,omitempty" url:"response,omitempty"`
	// Indicates whether the test is critical.
	Critical bool `json:"critical" url:"critical"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTestRequest) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CreateTestRequest) GetRequest() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Request
}

func (c *CreateTestRequest) GetResponse() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Response
}

func (c *CreateTestRequest) GetCritical() bool {
	if c == nil {
		return false
	}
	return c.Critical
}

func (c *CreateTestRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTestRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTestRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTestRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTestRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Test struct {
	// Unique identifier for the test.
	Id string `json:"id" url:"id"`
	// The name of the test.
	Name string `json:"name" url:"name"`
	// The request object for the test.
	Request map[string]interface{} `json:"request,omitempty" url:"request,omitempty"`
	// The expected response object for the test.
	Response map[string]interface{} `json:"response,omitempty" url:"response,omitempty"`
	// Indicates whether the test is critical.
	Critical bool `json:"critical" url:"critical"`
	// Indicates if the test resulted in an error.
	Error bool `json:"error" url:"error"`
	// Indicates if the test was successful.
	Success bool `json:"success" url:"success"`
	// The state of the test after execution.
	TestState *TestTestState `json:"testState,omitempty" url:"testState,omitempty"`
	// The timestamp when the test was last executed.
	LastExecuted *time.Time `json:"lastExecuted,omitempty" url:"lastExecuted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Test) GetId() string {
	if t == nil {
		return ""
	}
	return t.Id
}

func (t *Test) GetName() string {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *Test) GetRequest() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Request
}

func (t *Test) GetResponse() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Response
}

func (t *Test) GetCritical() bool {
	if t == nil {
		return false
	}
	return t.Critical
}

func (t *Test) GetError() bool {
	if t == nil {
		return false
	}
	return t.Error
}

func (t *Test) GetSuccess() bool {
	if t == nil {
		return false
	}
	return t.Success
}

func (t *Test) GetTestState() *TestTestState {
	if t == nil {
		return nil
	}
	return t.TestState
}

func (t *Test) GetLastExecuted() *time.Time {
	if t == nil {
		return nil
	}
	return t.LastExecuted
}

func (t *Test) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Test) UnmarshalJSON(data []byte) error {
	type embed Test
	var unmarshaler = struct {
		embed
		LastExecuted *internal.DateTime `json:"lastExecuted,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Test(unmarshaler.embed)
	t.LastExecuted = unmarshaler.LastExecuted.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Test) MarshalJSON() ([]byte, error) {
	type embed Test
	var marshaler = struct {
		embed
		LastExecuted *internal.DateTime `json:"lastExecuted,omitempty"`
	}{
		embed:        embed(*t),
		LastExecuted: internal.NewOptionalDateTime(t.LastExecuted),
	}
	return json.Marshal(marshaler)
}

func (t *Test) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TestListResponse = []*Test

// The state of the test after execution.
type TestTestState struct {
	// Execution time in seconds
	Duration *float64 `json:"duration,omitempty" url:"duration,omitempty"`
	// Actual response returned
	Response   map[string]interface{}                         `json:"response,omitempty" url:"response,omitempty"`
	Conditions []map[string]*TestTestStateConditionsItemValue `json:"conditions,omitempty" url:"conditions,omitempty"`
	// HTTP status code returned
	HttpStatus  *int  `json:"httpStatus,omitempty" url:"httpStatus,omitempty"`
	SuccessIdxs []int `json:"successIdxs,omitempty" url:"successIdxs,omitempty"`
	// Error message or flag indicating if evaluation error occurred
	EvaluationError *TestTestStateEvaluationError `json:"evaluationError,omitempty" url:"evaluationError,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TestTestState) GetDuration() *float64 {
	if t == nil {
		return nil
	}
	return t.Duration
}

func (t *TestTestState) GetResponse() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Response
}

func (t *TestTestState) GetConditions() []map[string]*TestTestStateConditionsItemValue {
	if t == nil {
		return nil
	}
	return t.Conditions
}

func (t *TestTestState) GetHttpStatus() *int {
	if t == nil {
		return nil
	}
	return t.HttpStatus
}

func (t *TestTestState) GetSuccessIdxs() []int {
	if t == nil {
		return nil
	}
	return t.SuccessIdxs
}

func (t *TestTestState) GetEvaluationError() *TestTestStateEvaluationError {
	if t == nil {
		return nil
	}
	return t.EvaluationError
}

func (t *TestTestState) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TestTestState) UnmarshalJSON(data []byte) error {
	type unmarshaler TestTestState
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TestTestState(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TestTestState) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TestTestStateConditionsItemValue struct {
	Result *bool   `json:"result,omitempty" url:"result,omitempty"`
	Err    *string `json:"err,omitempty" url:"err,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TestTestStateConditionsItemValue) GetResult() *bool {
	if t == nil {
		return nil
	}
	return t.Result
}

func (t *TestTestStateConditionsItemValue) GetErr() *string {
	if t == nil {
		return nil
	}
	return t.Err
}

func (t *TestTestStateConditionsItemValue) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TestTestStateConditionsItemValue) UnmarshalJSON(data []byte) error {
	type unmarshaler TestTestStateConditionsItemValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TestTestStateConditionsItemValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TestTestStateConditionsItemValue) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Error message or flag indicating if evaluation error occurred
type TestTestStateEvaluationError struct {
	Boolean bool
	String  string

	typ string
}

func NewTestTestStateEvaluationErrorFromBoolean(value bool) *TestTestStateEvaluationError {
	return &TestTestStateEvaluationError{typ: "Boolean", Boolean: value}
}

func NewTestTestStateEvaluationErrorFromString(value string) *TestTestStateEvaluationError {
	return &TestTestStateEvaluationError{typ: "String", String: value}
}

func (t *TestTestStateEvaluationError) GetBoolean() bool {
	if t == nil {
		return false
	}
	return t.Boolean
}

func (t *TestTestStateEvaluationError) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TestTestStateEvaluationError) UnmarshalJSON(data []byte) error {
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		t.typ = "Boolean"
		t.Boolean = valueBoolean
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TestTestStateEvaluationError) MarshalJSON() ([]byte, error) {
	if t.typ == "Boolean" || t.Boolean != false {
		return json.Marshal(t.Boolean)
	}
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TestTestStateEvaluationErrorVisitor interface {
	VisitBoolean(bool) error
	VisitString(string) error
}

func (t *TestTestStateEvaluationError) Accept(visitor TestTestStateEvaluationErrorVisitor) error {
	if t.typ == "Boolean" || t.Boolean != false {
		return visitor.VisitBoolean(t.Boolean)
	}
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}
