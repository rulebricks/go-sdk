// Code generated by Fern. DO NOT EDIT.

package contexts

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"
	internal "sdk/internal"
)

var (
	createContextRequestFieldName                 = big.NewInt(1 << 0)
	createContextRequestFieldSlug                 = big.NewInt(1 << 1)
	createContextRequestFieldDescription          = big.NewInt(1 << 2)
	createContextRequestFieldSchema               = big.NewInt(1 << 3)
	createContextRequestFieldAutoExecuteDecisions = big.NewInt(1 << 4)
	createContextRequestFieldTTLSeconds           = big.NewInt(1 << 5)
	createContextRequestFieldHistoryLimit         = big.NewInt(1 << 6)
	createContextRequestFieldOnSchemaMismatch     = big.NewInt(1 << 7)
	createContextRequestFieldWebhookOnSolve       = big.NewInt(1 << 8)
	createContextRequestFieldWebhookOnExpire      = big.NewInt(1 << 9)
)

type CreateContextRequest struct {
	// The name of the context.
	Name string `json:"name" url:"-"`
	// Optional custom slug. Auto-generated if not provided.
	Slug *string `json:"slug,omitempty" url:"-"`
	// The description of the context.
	Description *string `json:"description,omitempty" url:"-"`
	// Initial schema fields for the context.
	Schema []*CreateContextRequestSchemaItem `json:"schema,omitempty" url:"-"`
	// When true (default), bound rules and flows automatically execute when their inputs are satisfied.
	AutoExecuteDecisions *bool `json:"auto_execute_decisions,omitempty" url:"-"`
	// Time-to-live in seconds for live context instances. Instances expire after this duration.
	TTLSeconds *int `json:"ttl_seconds,omitempty" url:"-"`
	// Maximum number of history entries to retain per field.
	HistoryLimit *int `json:"history_limit,omitempty" url:"-"`
	// How to handle fields that don't match the schema.
	OnSchemaMismatch *CreateContextRequestOnSchemaMismatch `json:"on_schema_mismatch,omitempty" url:"-"`
	// Webhook URL called when a rule or flow successfully solves.
	WebhookOnSolve *string `json:"webhook_on_solve,omitempty" url:"-"`
	// Webhook URL called when a live context expires due to TTL.
	WebhookOnExpire *string `json:"webhook_on_expire,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CreateContextRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateContextRequest) SetName(name string) {
	c.Name = name
	c.require(createContextRequestFieldName)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateContextRequest) SetSlug(slug *string) {
	c.Slug = slug
	c.require(createContextRequestFieldSlug)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateContextRequest) SetDescription(description *string) {
	c.Description = description
	c.require(createContextRequestFieldDescription)
}

// SetSchema sets the Schema field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateContextRequest) SetSchema(schema []*CreateContextRequestSchemaItem) {
	c.Schema = schema
	c.require(createContextRequestFieldSchema)
}

// SetAutoExecuteDecisions sets the AutoExecuteDecisions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateContextRequest) SetAutoExecuteDecisions(autoExecuteDecisions *bool) {
	c.AutoExecuteDecisions = autoExecuteDecisions
	c.require(createContextRequestFieldAutoExecuteDecisions)
}

// SetTTLSeconds sets the TTLSeconds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateContextRequest) SetTTLSeconds(ttlSeconds *int) {
	c.TTLSeconds = ttlSeconds
	c.require(createContextRequestFieldTTLSeconds)
}

// SetHistoryLimit sets the HistoryLimit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateContextRequest) SetHistoryLimit(historyLimit *int) {
	c.HistoryLimit = historyLimit
	c.require(createContextRequestFieldHistoryLimit)
}

// SetOnSchemaMismatch sets the OnSchemaMismatch field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateContextRequest) SetOnSchemaMismatch(onSchemaMismatch *CreateContextRequestOnSchemaMismatch) {
	c.OnSchemaMismatch = onSchemaMismatch
	c.require(createContextRequestFieldOnSchemaMismatch)
}

// SetWebhookOnSolve sets the WebhookOnSolve field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateContextRequest) SetWebhookOnSolve(webhookOnSolve *string) {
	c.WebhookOnSolve = webhookOnSolve
	c.require(createContextRequestFieldWebhookOnSolve)
}

// SetWebhookOnExpire sets the WebhookOnExpire field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateContextRequest) SetWebhookOnExpire(webhookOnExpire *string) {
	c.WebhookOnExpire = webhookOnExpire
	c.require(createContextRequestFieldWebhookOnExpire)
}

var (
	deleteAdminRequestFieldID = big.NewInt(1 << 0)
)

type DeleteAdminRequest struct {
	// The unique identifier for the context.
	ID string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (d *DeleteAdminRequest) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteAdminRequest) SetID(id string) {
	d.ID = id
	d.require(deleteAdminRequestFieldID)
}

var (
	getAdminRequestFieldID = big.NewInt(1 << 0)
)

type GetAdminRequest struct {
	// The unique identifier for the context.
	ID string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (g *GetAdminRequest) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetAdminRequest) SetID(id string) {
	g.ID = id
	g.require(getAdminRequestFieldID)
}

// How to handle fields that don't match the schema.
type CreateContextRequestOnSchemaMismatch string

const (
	CreateContextRequestOnSchemaMismatchIgnore CreateContextRequestOnSchemaMismatch = "ignore"
	CreateContextRequestOnSchemaMismatchReject CreateContextRequestOnSchemaMismatch = "reject"
)

func NewCreateContextRequestOnSchemaMismatchFromString(s string) (CreateContextRequestOnSchemaMismatch, error) {
	switch s {
	case "ignore":
		return CreateContextRequestOnSchemaMismatchIgnore, nil
	case "reject":
		return CreateContextRequestOnSchemaMismatchReject, nil
	}
	var t CreateContextRequestOnSchemaMismatch
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CreateContextRequestOnSchemaMismatch) Ptr() *CreateContextRequestOnSchemaMismatch {
	return &c
}

var (
	createContextRequestSchemaItemFieldKey          = big.NewInt(1 << 0)
	createContextRequestSchemaItemFieldName         = big.NewInt(1 << 1)
	createContextRequestSchemaItemFieldType         = big.NewInt(1 << 2)
	createContextRequestSchemaItemFieldDefaultValue = big.NewInt(1 << 3)
)

type CreateContextRequestSchemaItem struct {
	Key          *string     `json:"key,omitempty" url:"key,omitempty"`
	Name         *string     `json:"name,omitempty" url:"name,omitempty"`
	Type         *string     `json:"type,omitempty" url:"type,omitempty"`
	DefaultValue interface{} `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateContextRequestSchemaItem) GetKey() *string {
	if c == nil {
		return nil
	}
	return c.Key
}

func (c *CreateContextRequestSchemaItem) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CreateContextRequestSchemaItem) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CreateContextRequestSchemaItem) GetDefaultValue() interface{} {
	if c == nil {
		return nil
	}
	return c.DefaultValue
}

func (c *CreateContextRequestSchemaItem) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateContextRequestSchemaItem) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateContextRequestSchemaItem) SetKey(key *string) {
	c.Key = key
	c.require(createContextRequestSchemaItemFieldKey)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateContextRequestSchemaItem) SetName(name *string) {
	c.Name = name
	c.require(createContextRequestSchemaItemFieldName)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateContextRequestSchemaItem) SetType(type_ *string) {
	c.Type = type_
	c.require(createContextRequestSchemaItemFieldType)
}

// SetDefaultValue sets the DefaultValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateContextRequestSchemaItem) SetDefaultValue(defaultValue interface{}) {
	c.DefaultValue = defaultValue
	c.require(createContextRequestSchemaItemFieldDefaultValue)
}

func (c *CreateContextRequestSchemaItem) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateContextRequestSchemaItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateContextRequestSchemaItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateContextRequestSchemaItem) MarshalJSON() ([]byte, error) {
	type embed CreateContextRequestSchemaItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CreateContextRequestSchemaItem) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// How to handle fields that don't match the schema.
type UpdateContextRequestOnSchemaMismatch string

const (
	UpdateContextRequestOnSchemaMismatchIgnore UpdateContextRequestOnSchemaMismatch = "ignore"
	UpdateContextRequestOnSchemaMismatchReject UpdateContextRequestOnSchemaMismatch = "reject"
)

func NewUpdateContextRequestOnSchemaMismatchFromString(s string) (UpdateContextRequestOnSchemaMismatch, error) {
	switch s {
	case "ignore":
		return UpdateContextRequestOnSchemaMismatchIgnore, nil
	case "reject":
		return UpdateContextRequestOnSchemaMismatchReject, nil
	}
	var t UpdateContextRequestOnSchemaMismatch
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateContextRequestOnSchemaMismatch) Ptr() *UpdateContextRequestOnSchemaMismatch {
	return &u
}

var (
	updateContextRequestSchemaItemFieldKey          = big.NewInt(1 << 0)
	updateContextRequestSchemaItemFieldName         = big.NewInt(1 << 1)
	updateContextRequestSchemaItemFieldType         = big.NewInt(1 << 2)
	updateContextRequestSchemaItemFieldDefaultValue = big.NewInt(1 << 3)
)

type UpdateContextRequestSchemaItem struct {
	Key          *string     `json:"key,omitempty" url:"key,omitempty"`
	Name         *string     `json:"name,omitempty" url:"name,omitempty"`
	Type         *string     `json:"type,omitempty" url:"type,omitempty"`
	DefaultValue interface{} `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateContextRequestSchemaItem) GetKey() *string {
	if u == nil {
		return nil
	}
	return u.Key
}

func (u *UpdateContextRequestSchemaItem) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UpdateContextRequestSchemaItem) GetType() *string {
	if u == nil {
		return nil
	}
	return u.Type
}

func (u *UpdateContextRequestSchemaItem) GetDefaultValue() interface{} {
	if u == nil {
		return nil
	}
	return u.DefaultValue
}

func (u *UpdateContextRequestSchemaItem) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateContextRequestSchemaItem) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateContextRequestSchemaItem) SetKey(key *string) {
	u.Key = key
	u.require(updateContextRequestSchemaItemFieldKey)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateContextRequestSchemaItem) SetName(name *string) {
	u.Name = name
	u.require(updateContextRequestSchemaItemFieldName)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateContextRequestSchemaItem) SetType(type_ *string) {
	u.Type = type_
	u.require(updateContextRequestSchemaItemFieldType)
}

// SetDefaultValue sets the DefaultValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateContextRequestSchemaItem) SetDefaultValue(defaultValue interface{}) {
	u.DefaultValue = defaultValue
	u.require(updateContextRequestSchemaItemFieldDefaultValue)
}

func (u *UpdateContextRequestSchemaItem) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateContextRequestSchemaItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateContextRequestSchemaItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateContextRequestSchemaItem) MarshalJSON() ([]byte, error) {
	type embed UpdateContextRequestSchemaItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateContextRequestSchemaItem) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	updateContextRequestFieldID                   = big.NewInt(1 << 0)
	updateContextRequestFieldName                 = big.NewInt(1 << 1)
	updateContextRequestFieldSlug                 = big.NewInt(1 << 2)
	updateContextRequestFieldDescription          = big.NewInt(1 << 3)
	updateContextRequestFieldSchema               = big.NewInt(1 << 4)
	updateContextRequestFieldAutoExecuteDecisions = big.NewInt(1 << 5)
	updateContextRequestFieldTTLSeconds           = big.NewInt(1 << 6)
	updateContextRequestFieldHistoryLimit         = big.NewInt(1 << 7)
	updateContextRequestFieldOnSchemaMismatch     = big.NewInt(1 << 8)
	updateContextRequestFieldWebhookOnSolve       = big.NewInt(1 << 9)
	updateContextRequestFieldWebhookOnExpire      = big.NewInt(1 << 10)
)

type UpdateContextRequest struct {
	// The unique identifier for the context.
	ID string `json:"-" url:"-"`
	// The name of the context.
	Name *string `json:"name,omitempty" url:"-"`
	// The slug of the context.
	Slug *string `json:"slug,omitempty" url:"-"`
	// The description of the context.
	Description *string `json:"description,omitempty" url:"-"`
	// Updated schema fields for the context.
	Schema []*UpdateContextRequestSchemaItem `json:"schema,omitempty" url:"-"`
	// When true, bound rules and flows automatically execute when their inputs are satisfied.
	AutoExecuteDecisions *bool `json:"auto_execute_decisions,omitempty" url:"-"`
	// Time-to-live in seconds for live context instances. Instances expire after this duration.
	TTLSeconds *int `json:"ttl_seconds,omitempty" url:"-"`
	// Maximum number of history entries to retain per field.
	HistoryLimit *int `json:"history_limit,omitempty" url:"-"`
	// How to handle fields that don't match the schema.
	OnSchemaMismatch *UpdateContextRequestOnSchemaMismatch `json:"on_schema_mismatch,omitempty" url:"-"`
	// Webhook URL called when a rule or flow successfully solves.
	WebhookOnSolve *string `json:"webhook_on_solve,omitempty" url:"-"`
	// Webhook URL called when a live context expires due to TTL.
	WebhookOnExpire *string `json:"webhook_on_expire,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (u *UpdateContextRequest) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateContextRequest) SetID(id string) {
	u.ID = id
	u.require(updateContextRequestFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateContextRequest) SetName(name *string) {
	u.Name = name
	u.require(updateContextRequestFieldName)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateContextRequest) SetSlug(slug *string) {
	u.Slug = slug
	u.require(updateContextRequestFieldSlug)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateContextRequest) SetDescription(description *string) {
	u.Description = description
	u.require(updateContextRequestFieldDescription)
}

// SetSchema sets the Schema field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateContextRequest) SetSchema(schema []*UpdateContextRequestSchemaItem) {
	u.Schema = schema
	u.require(updateContextRequestFieldSchema)
}

// SetAutoExecuteDecisions sets the AutoExecuteDecisions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateContextRequest) SetAutoExecuteDecisions(autoExecuteDecisions *bool) {
	u.AutoExecuteDecisions = autoExecuteDecisions
	u.require(updateContextRequestFieldAutoExecuteDecisions)
}

// SetTTLSeconds sets the TTLSeconds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateContextRequest) SetTTLSeconds(ttlSeconds *int) {
	u.TTLSeconds = ttlSeconds
	u.require(updateContextRequestFieldTTLSeconds)
}

// SetHistoryLimit sets the HistoryLimit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateContextRequest) SetHistoryLimit(historyLimit *int) {
	u.HistoryLimit = historyLimit
	u.require(updateContextRequestFieldHistoryLimit)
}

// SetOnSchemaMismatch sets the OnSchemaMismatch field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateContextRequest) SetOnSchemaMismatch(onSchemaMismatch *UpdateContextRequestOnSchemaMismatch) {
	u.OnSchemaMismatch = onSchemaMismatch
	u.require(updateContextRequestFieldOnSchemaMismatch)
}

// SetWebhookOnSolve sets the WebhookOnSolve field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateContextRequest) SetWebhookOnSolve(webhookOnSolve *string) {
	u.WebhookOnSolve = webhookOnSolve
	u.require(updateContextRequestFieldWebhookOnSolve)
}

// SetWebhookOnExpire sets the WebhookOnExpire field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateContextRequest) SetWebhookOnExpire(webhookOnExpire *string) {
	u.WebhookOnExpire = webhookOnExpire
	u.require(updateContextRequestFieldWebhookOnExpire)
}
