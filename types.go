// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"
	internal "sdk/internal"
	time "time"
)

// Base properties for a context.
var (
	contextBaseFieldID                   = big.NewInt(1 << 0)
	contextBaseFieldName                 = big.NewInt(1 << 1)
	contextBaseFieldSlug                 = big.NewInt(1 << 2)
	contextBaseFieldDescription          = big.NewInt(1 << 3)
	contextBaseFieldAutoExecuteDecisions = big.NewInt(1 << 4)
	contextBaseFieldTTLSeconds           = big.NewInt(1 << 5)
	contextBaseFieldHistoryLimit         = big.NewInt(1 << 6)
	contextBaseFieldOnSchemaMismatch     = big.NewInt(1 << 7)
	contextBaseFieldWebhookOnSolve       = big.NewInt(1 << 8)
	contextBaseFieldWebhookOnExpire      = big.NewInt(1 << 9)
)

type ContextBase struct {
	// The unique identifier for the context.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the context.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The unique slug for the context used in API requests.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// The description of the context.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// When true, bound rules and flows automatically execute when their inputs are satisfied. When false, users must manually call /solve or /flows endpoints.
	AutoExecuteDecisions *bool `json:"auto_execute_decisions,omitempty" url:"auto_execute_decisions,omitempty"`
	// Time-to-live in seconds for live context instances. Instances expire after this duration.
	TTLSeconds *int `json:"ttl_seconds,omitempty" url:"ttl_seconds,omitempty"`
	// Maximum number of history entries to retain per field.
	HistoryLimit *int `json:"history_limit,omitempty" url:"history_limit,omitempty"`
	// How to handle fields that don't match the schema: 'ignore' filters them out, 'reject' returns an error.
	OnSchemaMismatch *ContextBaseOnSchemaMismatch `json:"on_schema_mismatch,omitempty" url:"on_schema_mismatch,omitempty"`
	// Webhook URL called when a rule or flow successfully solves for a live context.
	WebhookOnSolve *string `json:"webhook_on_solve,omitempty" url:"webhook_on_solve,omitempty"`
	// Webhook URL called when a live context expires due to TTL.
	WebhookOnExpire *string `json:"webhook_on_expire,omitempty" url:"webhook_on_expire,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextBase) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *ContextBase) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *ContextBase) GetSlug() *string {
	if c == nil {
		return nil
	}
	return c.Slug
}

func (c *ContextBase) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *ContextBase) GetAutoExecuteDecisions() *bool {
	if c == nil {
		return nil
	}
	return c.AutoExecuteDecisions
}

func (c *ContextBase) GetTTLSeconds() *int {
	if c == nil {
		return nil
	}
	return c.TTLSeconds
}

func (c *ContextBase) GetHistoryLimit() *int {
	if c == nil {
		return nil
	}
	return c.HistoryLimit
}

func (c *ContextBase) GetOnSchemaMismatch() *ContextBaseOnSchemaMismatch {
	if c == nil {
		return nil
	}
	return c.OnSchemaMismatch
}

func (c *ContextBase) GetWebhookOnSolve() *string {
	if c == nil {
		return nil
	}
	return c.WebhookOnSolve
}

func (c *ContextBase) GetWebhookOnExpire() *string {
	if c == nil {
		return nil
	}
	return c.WebhookOnExpire
}

func (c *ContextBase) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextBase) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextBase) SetID(id *string) {
	c.ID = id
	c.require(contextBaseFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextBase) SetName(name *string) {
	c.Name = name
	c.require(contextBaseFieldName)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextBase) SetSlug(slug *string) {
	c.Slug = slug
	c.require(contextBaseFieldSlug)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextBase) SetDescription(description *string) {
	c.Description = description
	c.require(contextBaseFieldDescription)
}

// SetAutoExecuteDecisions sets the AutoExecuteDecisions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextBase) SetAutoExecuteDecisions(autoExecuteDecisions *bool) {
	c.AutoExecuteDecisions = autoExecuteDecisions
	c.require(contextBaseFieldAutoExecuteDecisions)
}

// SetTTLSeconds sets the TTLSeconds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextBase) SetTTLSeconds(ttlSeconds *int) {
	c.TTLSeconds = ttlSeconds
	c.require(contextBaseFieldTTLSeconds)
}

// SetHistoryLimit sets the HistoryLimit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextBase) SetHistoryLimit(historyLimit *int) {
	c.HistoryLimit = historyLimit
	c.require(contextBaseFieldHistoryLimit)
}

// SetOnSchemaMismatch sets the OnSchemaMismatch field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextBase) SetOnSchemaMismatch(onSchemaMismatch *ContextBaseOnSchemaMismatch) {
	c.OnSchemaMismatch = onSchemaMismatch
	c.require(contextBaseFieldOnSchemaMismatch)
}

// SetWebhookOnSolve sets the WebhookOnSolve field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextBase) SetWebhookOnSolve(webhookOnSolve *string) {
	c.WebhookOnSolve = webhookOnSolve
	c.require(contextBaseFieldWebhookOnSolve)
}

// SetWebhookOnExpire sets the WebhookOnExpire field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextBase) SetWebhookOnExpire(webhookOnExpire *string) {
	c.WebhookOnExpire = webhookOnExpire
	c.require(contextBaseFieldWebhookOnExpire)
}

func (c *ContextBase) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextBase) MarshalJSON() ([]byte, error) {
	type embed ContextBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextBase) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// How to handle fields that don't match the schema: 'ignore' filters them out, 'reject' returns an error.
type ContextBaseOnSchemaMismatch string

const (
	ContextBaseOnSchemaMismatchIgnore ContextBaseOnSchemaMismatch = "ignore"
	ContextBaseOnSchemaMismatchReject ContextBaseOnSchemaMismatch = "reject"
)

func NewContextBaseOnSchemaMismatchFromString(s string) (ContextBaseOnSchemaMismatch, error) {
	switch s {
	case "ignore":
		return ContextBaseOnSchemaMismatchIgnore, nil
	case "reject":
		return ContextBaseOnSchemaMismatchReject, nil
	}
	var t ContextBaseOnSchemaMismatch
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ContextBaseOnSchemaMismatch) Ptr() *ContextBaseOnSchemaMismatch {
	return &c
}

var (
	contextDetailFieldID                   = big.NewInt(1 << 0)
	contextDetailFieldName                 = big.NewInt(1 << 1)
	contextDetailFieldSlug                 = big.NewInt(1 << 2)
	contextDetailFieldDescription          = big.NewInt(1 << 3)
	contextDetailFieldAutoExecuteDecisions = big.NewInt(1 << 4)
	contextDetailFieldTTLSeconds           = big.NewInt(1 << 5)
	contextDetailFieldHistoryLimit         = big.NewInt(1 << 6)
	contextDetailFieldOnSchemaMismatch     = big.NewInt(1 << 7)
	contextDetailFieldWebhookOnSolve       = big.NewInt(1 << 8)
	contextDetailFieldWebhookOnExpire      = big.NewInt(1 << 9)
	contextDetailFieldSchema               = big.NewInt(1 << 10)
	contextDetailFieldIdentityFact         = big.NewInt(1 << 11)
	contextDetailFieldUserGroups           = big.NewInt(1 << 12)
	contextDetailFieldFolder               = big.NewInt(1 << 13)
	contextDetailFieldBoundRules           = big.NewInt(1 << 14)
	contextDetailFieldBoundFlows           = big.NewInt(1 << 15)
	contextDetailFieldRelationships        = big.NewInt(1 << 16)
	contextDetailFieldCreatedAt            = big.NewInt(1 << 17)
	contextDetailFieldUpdatedAt            = big.NewInt(1 << 18)
)

type ContextDetail struct {
	// The unique identifier for the context.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the context.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The unique slug for the context used in API requests.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// The description of the context.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// When true, bound rules and flows automatically execute when their inputs are satisfied. When false, users must manually call /solve or /flows endpoints.
	AutoExecuteDecisions *bool `json:"auto_execute_decisions,omitempty" url:"auto_execute_decisions,omitempty"`
	// Time-to-live in seconds for live context instances. Instances expire after this duration.
	TTLSeconds *int `json:"ttl_seconds,omitempty" url:"ttl_seconds,omitempty"`
	// Maximum number of history entries to retain per field.
	HistoryLimit *int `json:"history_limit,omitempty" url:"history_limit,omitempty"`
	// How to handle fields that don't match the schema: 'ignore' filters them out, 'reject' returns an error.
	OnSchemaMismatch *ContextBaseOnSchemaMismatch `json:"on_schema_mismatch,omitempty" url:"on_schema_mismatch,omitempty"`
	// Webhook URL called when a rule or flow successfully solves for a live context.
	WebhookOnSolve *string `json:"webhook_on_solve,omitempty" url:"webhook_on_solve,omitempty"`
	// Webhook URL called when a live context expires due to TTL.
	WebhookOnExpire *string        `json:"webhook_on_expire,omitempty" url:"webhook_on_expire,omitempty"`
	Schema          *ContextSchema `json:"schema,omitempty" url:"schema,omitempty"`
	// The field key used as the unique identifier for instances.
	IdentityFact *string `json:"identity_fact,omitempty" url:"identity_fact,omitempty"`
	// User groups that can interact with this context.
	UserGroups []string `json:"user_groups,omitempty" url:"user_groups,omitempty"`
	// Folder/tag this context belongs to.
	Folder *ContextDetailFolder `json:"folder,omitempty" url:"folder,omitempty"`
	// Rules bound to this context.
	BoundRules []*ContextDetailBoundRulesItem `json:"bound_rules,omitempty" url:"bound_rules,omitempty"`
	// Flows bound to this context (via their origin rule).
	BoundFlows    []*ContextDetailBoundFlowsItem `json:"bound_flows,omitempty" url:"bound_flows,omitempty"`
	Relationships *ContextDetailRelationships    `json:"relationships,omitempty" url:"relationships,omitempty"`
	// When the context was created.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// When the context was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextDetail) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *ContextDetail) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *ContextDetail) GetSlug() *string {
	if c == nil {
		return nil
	}
	return c.Slug
}

func (c *ContextDetail) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *ContextDetail) GetAutoExecuteDecisions() *bool {
	if c == nil {
		return nil
	}
	return c.AutoExecuteDecisions
}

func (c *ContextDetail) GetTTLSeconds() *int {
	if c == nil {
		return nil
	}
	return c.TTLSeconds
}

func (c *ContextDetail) GetHistoryLimit() *int {
	if c == nil {
		return nil
	}
	return c.HistoryLimit
}

func (c *ContextDetail) GetOnSchemaMismatch() *ContextBaseOnSchemaMismatch {
	if c == nil {
		return nil
	}
	return c.OnSchemaMismatch
}

func (c *ContextDetail) GetWebhookOnSolve() *string {
	if c == nil {
		return nil
	}
	return c.WebhookOnSolve
}

func (c *ContextDetail) GetWebhookOnExpire() *string {
	if c == nil {
		return nil
	}
	return c.WebhookOnExpire
}

func (c *ContextDetail) GetSchema() *ContextSchema {
	if c == nil {
		return nil
	}
	return c.Schema
}

func (c *ContextDetail) GetIdentityFact() *string {
	if c == nil {
		return nil
	}
	return c.IdentityFact
}

func (c *ContextDetail) GetUserGroups() []string {
	if c == nil {
		return nil
	}
	return c.UserGroups
}

func (c *ContextDetail) GetFolder() *ContextDetailFolder {
	if c == nil {
		return nil
	}
	return c.Folder
}

func (c *ContextDetail) GetBoundRules() []*ContextDetailBoundRulesItem {
	if c == nil {
		return nil
	}
	return c.BoundRules
}

func (c *ContextDetail) GetBoundFlows() []*ContextDetailBoundFlowsItem {
	if c == nil {
		return nil
	}
	return c.BoundFlows
}

func (c *ContextDetail) GetRelationships() *ContextDetailRelationships {
	if c == nil {
		return nil
	}
	return c.Relationships
}

func (c *ContextDetail) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *ContextDetail) GetUpdatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *ContextDetail) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextDetail) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetID(id *string) {
	c.ID = id
	c.require(contextDetailFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetName(name *string) {
	c.Name = name
	c.require(contextDetailFieldName)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetSlug(slug *string) {
	c.Slug = slug
	c.require(contextDetailFieldSlug)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetDescription(description *string) {
	c.Description = description
	c.require(contextDetailFieldDescription)
}

// SetAutoExecuteDecisions sets the AutoExecuteDecisions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetAutoExecuteDecisions(autoExecuteDecisions *bool) {
	c.AutoExecuteDecisions = autoExecuteDecisions
	c.require(contextDetailFieldAutoExecuteDecisions)
}

// SetTTLSeconds sets the TTLSeconds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetTTLSeconds(ttlSeconds *int) {
	c.TTLSeconds = ttlSeconds
	c.require(contextDetailFieldTTLSeconds)
}

// SetHistoryLimit sets the HistoryLimit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetHistoryLimit(historyLimit *int) {
	c.HistoryLimit = historyLimit
	c.require(contextDetailFieldHistoryLimit)
}

// SetOnSchemaMismatch sets the OnSchemaMismatch field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetOnSchemaMismatch(onSchemaMismatch *ContextBaseOnSchemaMismatch) {
	c.OnSchemaMismatch = onSchemaMismatch
	c.require(contextDetailFieldOnSchemaMismatch)
}

// SetWebhookOnSolve sets the WebhookOnSolve field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetWebhookOnSolve(webhookOnSolve *string) {
	c.WebhookOnSolve = webhookOnSolve
	c.require(contextDetailFieldWebhookOnSolve)
}

// SetWebhookOnExpire sets the WebhookOnExpire field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetWebhookOnExpire(webhookOnExpire *string) {
	c.WebhookOnExpire = webhookOnExpire
	c.require(contextDetailFieldWebhookOnExpire)
}

// SetSchema sets the Schema field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetSchema(schema *ContextSchema) {
	c.Schema = schema
	c.require(contextDetailFieldSchema)
}

// SetIdentityFact sets the IdentityFact field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetIdentityFact(identityFact *string) {
	c.IdentityFact = identityFact
	c.require(contextDetailFieldIdentityFact)
}

// SetUserGroups sets the UserGroups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetUserGroups(userGroups []string) {
	c.UserGroups = userGroups
	c.require(contextDetailFieldUserGroups)
}

// SetFolder sets the Folder field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetFolder(folder *ContextDetailFolder) {
	c.Folder = folder
	c.require(contextDetailFieldFolder)
}

// SetBoundRules sets the BoundRules field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetBoundRules(boundRules []*ContextDetailBoundRulesItem) {
	c.BoundRules = boundRules
	c.require(contextDetailFieldBoundRules)
}

// SetBoundFlows sets the BoundFlows field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetBoundFlows(boundFlows []*ContextDetailBoundFlowsItem) {
	c.BoundFlows = boundFlows
	c.require(contextDetailFieldBoundFlows)
}

// SetRelationships sets the Relationships field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetRelationships(relationships *ContextDetailRelationships) {
	c.Relationships = relationships
	c.require(contextDetailFieldRelationships)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetCreatedAt(createdAt *time.Time) {
	c.CreatedAt = createdAt
	c.require(contextDetailFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetail) SetUpdatedAt(updatedAt *time.Time) {
	c.UpdatedAt = updatedAt
	c.require(contextDetailFieldUpdatedAt)
}

func (c *ContextDetail) UnmarshalJSON(data []byte) error {
	type embed ContextDetail
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ContextDetail(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextDetail) MarshalJSON() ([]byte, error) {
	type embed ContextDetail
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewOptionalDateTime(c.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(c.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextDetail) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	contextDetailBoundFlowsItemFieldID         = big.NewInt(1 << 0)
	contextDetailBoundFlowsItemFieldName       = big.NewInt(1 << 1)
	contextDetailBoundFlowsItemFieldSlug       = big.NewInt(1 << 2)
	contextDetailBoundFlowsItemFieldPublished  = big.NewInt(1 << 3)
	contextDetailBoundFlowsItemFieldOriginRule = big.NewInt(1 << 4)
)

type ContextDetailBoundFlowsItem struct {
	ID         *string                                `json:"id,omitempty" url:"id,omitempty"`
	Name       *string                                `json:"name,omitempty" url:"name,omitempty"`
	Slug       *string                                `json:"slug,omitempty" url:"slug,omitempty"`
	Published  *bool                                  `json:"published,omitempty" url:"published,omitempty"`
	OriginRule *ContextDetailBoundFlowsItemOriginRule `json:"origin_rule,omitempty" url:"origin_rule,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextDetailBoundFlowsItem) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *ContextDetailBoundFlowsItem) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *ContextDetailBoundFlowsItem) GetSlug() *string {
	if c == nil {
		return nil
	}
	return c.Slug
}

func (c *ContextDetailBoundFlowsItem) GetPublished() *bool {
	if c == nil {
		return nil
	}
	return c.Published
}

func (c *ContextDetailBoundFlowsItem) GetOriginRule() *ContextDetailBoundFlowsItemOriginRule {
	if c == nil {
		return nil
	}
	return c.OriginRule
}

func (c *ContextDetailBoundFlowsItem) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextDetailBoundFlowsItem) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetailBoundFlowsItem) SetID(id *string) {
	c.ID = id
	c.require(contextDetailBoundFlowsItemFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetailBoundFlowsItem) SetName(name *string) {
	c.Name = name
	c.require(contextDetailBoundFlowsItemFieldName)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetailBoundFlowsItem) SetSlug(slug *string) {
	c.Slug = slug
	c.require(contextDetailBoundFlowsItemFieldSlug)
}

// SetPublished sets the Published field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetailBoundFlowsItem) SetPublished(published *bool) {
	c.Published = published
	c.require(contextDetailBoundFlowsItemFieldPublished)
}

// SetOriginRule sets the OriginRule field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetailBoundFlowsItem) SetOriginRule(originRule *ContextDetailBoundFlowsItemOriginRule) {
	c.OriginRule = originRule
	c.require(contextDetailBoundFlowsItemFieldOriginRule)
}

func (c *ContextDetailBoundFlowsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextDetailBoundFlowsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextDetailBoundFlowsItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextDetailBoundFlowsItem) MarshalJSON() ([]byte, error) {
	type embed ContextDetailBoundFlowsItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextDetailBoundFlowsItem) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	contextDetailBoundFlowsItemOriginRuleFieldID   = big.NewInt(1 << 0)
	contextDetailBoundFlowsItemOriginRuleFieldName = big.NewInt(1 << 1)
	contextDetailBoundFlowsItemOriginRuleFieldSlug = big.NewInt(1 << 2)
)

type ContextDetailBoundFlowsItemOriginRule struct {
	ID   *string `json:"id,omitempty" url:"id,omitempty"`
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextDetailBoundFlowsItemOriginRule) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *ContextDetailBoundFlowsItemOriginRule) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *ContextDetailBoundFlowsItemOriginRule) GetSlug() *string {
	if c == nil {
		return nil
	}
	return c.Slug
}

func (c *ContextDetailBoundFlowsItemOriginRule) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextDetailBoundFlowsItemOriginRule) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetailBoundFlowsItemOriginRule) SetID(id *string) {
	c.ID = id
	c.require(contextDetailBoundFlowsItemOriginRuleFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetailBoundFlowsItemOriginRule) SetName(name *string) {
	c.Name = name
	c.require(contextDetailBoundFlowsItemOriginRuleFieldName)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetailBoundFlowsItemOriginRule) SetSlug(slug *string) {
	c.Slug = slug
	c.require(contextDetailBoundFlowsItemOriginRuleFieldSlug)
}

func (c *ContextDetailBoundFlowsItemOriginRule) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextDetailBoundFlowsItemOriginRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextDetailBoundFlowsItemOriginRule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextDetailBoundFlowsItemOriginRule) MarshalJSON() ([]byte, error) {
	type embed ContextDetailBoundFlowsItemOriginRule
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextDetailBoundFlowsItemOriginRule) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	contextDetailBoundRulesItemFieldID        = big.NewInt(1 << 0)
	contextDetailBoundRulesItemFieldName      = big.NewInt(1 << 1)
	contextDetailBoundRulesItemFieldSlug      = big.NewInt(1 << 2)
	contextDetailBoundRulesItemFieldPublished = big.NewInt(1 << 3)
)

type ContextDetailBoundRulesItem struct {
	ID        *string `json:"id,omitempty" url:"id,omitempty"`
	Name      *string `json:"name,omitempty" url:"name,omitempty"`
	Slug      *string `json:"slug,omitempty" url:"slug,omitempty"`
	Published *bool   `json:"published,omitempty" url:"published,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextDetailBoundRulesItem) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *ContextDetailBoundRulesItem) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *ContextDetailBoundRulesItem) GetSlug() *string {
	if c == nil {
		return nil
	}
	return c.Slug
}

func (c *ContextDetailBoundRulesItem) GetPublished() *bool {
	if c == nil {
		return nil
	}
	return c.Published
}

func (c *ContextDetailBoundRulesItem) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextDetailBoundRulesItem) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetailBoundRulesItem) SetID(id *string) {
	c.ID = id
	c.require(contextDetailBoundRulesItemFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetailBoundRulesItem) SetName(name *string) {
	c.Name = name
	c.require(contextDetailBoundRulesItemFieldName)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetailBoundRulesItem) SetSlug(slug *string) {
	c.Slug = slug
	c.require(contextDetailBoundRulesItemFieldSlug)
}

// SetPublished sets the Published field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetailBoundRulesItem) SetPublished(published *bool) {
	c.Published = published
	c.require(contextDetailBoundRulesItemFieldPublished)
}

func (c *ContextDetailBoundRulesItem) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextDetailBoundRulesItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextDetailBoundRulesItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextDetailBoundRulesItem) MarshalJSON() ([]byte, error) {
	type embed ContextDetailBoundRulesItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextDetailBoundRulesItem) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Folder/tag this context belongs to.
var (
	contextDetailFolderFieldID   = big.NewInt(1 << 0)
	contextDetailFolderFieldName = big.NewInt(1 << 1)
)

type ContextDetailFolder struct {
	ID   *string `json:"id,omitempty" url:"id,omitempty"`
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextDetailFolder) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *ContextDetailFolder) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *ContextDetailFolder) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextDetailFolder) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetailFolder) SetID(id *string) {
	c.ID = id
	c.require(contextDetailFolderFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetailFolder) SetName(name *string) {
	c.Name = name
	c.require(contextDetailFolderFieldName)
}

func (c *ContextDetailFolder) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextDetailFolder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextDetailFolder(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextDetailFolder) MarshalJSON() ([]byte, error) {
	type embed ContextDetailFolder
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextDetailFolder) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	contextDetailRelationshipsFieldOutgoing = big.NewInt(1 << 0)
	contextDetailRelationshipsFieldIncoming = big.NewInt(1 << 1)
)

type ContextDetailRelationships struct {
	Outgoing []*ContextRelationshipOutgoing `json:"outgoing,omitempty" url:"outgoing,omitempty"`
	Incoming []*ContextRelationshipIncoming `json:"incoming,omitempty" url:"incoming,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextDetailRelationships) GetOutgoing() []*ContextRelationshipOutgoing {
	if c == nil {
		return nil
	}
	return c.Outgoing
}

func (c *ContextDetailRelationships) GetIncoming() []*ContextRelationshipIncoming {
	if c == nil {
		return nil
	}
	return c.Incoming
}

func (c *ContextDetailRelationships) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextDetailRelationships) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetOutgoing sets the Outgoing field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetailRelationships) SetOutgoing(outgoing []*ContextRelationshipOutgoing) {
	c.Outgoing = outgoing
	c.require(contextDetailRelationshipsFieldOutgoing)
}

// SetIncoming sets the Incoming field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextDetailRelationships) SetIncoming(incoming []*ContextRelationshipIncoming) {
	c.Incoming = incoming
	c.require(contextDetailRelationshipsFieldIncoming)
}

func (c *ContextDetailRelationships) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextDetailRelationships
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextDetailRelationships(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextDetailRelationships) MarshalJSON() ([]byte, error) {
	type embed ContextDetailRelationships
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextDetailRelationships) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContextListResponse = []*ContextDetail

var (
	contextRelationshipBaseFieldID          = big.NewInt(1 << 0)
	contextRelationshipBaseFieldType        = big.NewInt(1 << 1)
	contextRelationshipBaseFieldForeignKey  = big.NewInt(1 << 2)
	contextRelationshipBaseFieldName        = big.NewInt(1 << 3)
	contextRelationshipBaseFieldDescription = big.NewInt(1 << 4)
)

type ContextRelationshipBase struct {
	// The unique identifier for the relationship.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of relationship.
	Type *ContextRelationshipBaseType `json:"type,omitempty" url:"type,omitempty"`
	// The field key used as the foreign key.
	ForeignKey *string `json:"foreignKey,omitempty" url:"foreignKey,omitempty"`
	// Display name for the relationship.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Description of the relationship.
	Description *string `json:"description,omitempty" url:"description,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextRelationshipBase) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *ContextRelationshipBase) GetType() *ContextRelationshipBaseType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ContextRelationshipBase) GetForeignKey() *string {
	if c == nil {
		return nil
	}
	return c.ForeignKey
}

func (c *ContextRelationshipBase) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *ContextRelationshipBase) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *ContextRelationshipBase) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextRelationshipBase) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipBase) SetID(id *string) {
	c.ID = id
	c.require(contextRelationshipBaseFieldID)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipBase) SetType(type_ *ContextRelationshipBaseType) {
	c.Type = type_
	c.require(contextRelationshipBaseFieldType)
}

// SetForeignKey sets the ForeignKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipBase) SetForeignKey(foreignKey *string) {
	c.ForeignKey = foreignKey
	c.require(contextRelationshipBaseFieldForeignKey)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipBase) SetName(name *string) {
	c.Name = name
	c.require(contextRelationshipBaseFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipBase) SetDescription(description *string) {
	c.Description = description
	c.require(contextRelationshipBaseFieldDescription)
}

func (c *ContextRelationshipBase) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextRelationshipBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextRelationshipBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextRelationshipBase) MarshalJSON() ([]byte, error) {
	type embed ContextRelationshipBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextRelationshipBase) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of relationship.
type ContextRelationshipBaseType string

const (
	ContextRelationshipBaseTypeOneToOne  ContextRelationshipBaseType = "one-to-one"
	ContextRelationshipBaseTypeOneToMany ContextRelationshipBaseType = "one-to-many"
	ContextRelationshipBaseTypeManyToOne ContextRelationshipBaseType = "many-to-one"
)

func NewContextRelationshipBaseTypeFromString(s string) (ContextRelationshipBaseType, error) {
	switch s {
	case "one-to-one":
		return ContextRelationshipBaseTypeOneToOne, nil
	case "one-to-many":
		return ContextRelationshipBaseTypeOneToMany, nil
	case "many-to-one":
		return ContextRelationshipBaseTypeManyToOne, nil
	}
	var t ContextRelationshipBaseType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ContextRelationshipBaseType) Ptr() *ContextRelationshipBaseType {
	return &c
}

var (
	contextRelationshipIncomingFieldID            = big.NewInt(1 << 0)
	contextRelationshipIncomingFieldType          = big.NewInt(1 << 1)
	contextRelationshipIncomingFieldForeignKey    = big.NewInt(1 << 2)
	contextRelationshipIncomingFieldName          = big.NewInt(1 << 3)
	contextRelationshipIncomingFieldDescription   = big.NewInt(1 << 4)
	contextRelationshipIncomingFieldSourceContext = big.NewInt(1 << 5)
)

type ContextRelationshipIncoming struct {
	// The unique identifier for the relationship.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of relationship.
	Type *ContextRelationshipBaseType `json:"type,omitempty" url:"type,omitempty"`
	// The field key used as the foreign key.
	ForeignKey *string `json:"foreignKey,omitempty" url:"foreignKey,omitempty"`
	// Display name for the relationship.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Description of the relationship.
	Description   *string                                   `json:"description,omitempty" url:"description,omitempty"`
	SourceContext *ContextRelationshipIncomingSourceContext `json:"sourceContext,omitempty" url:"sourceContext,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextRelationshipIncoming) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *ContextRelationshipIncoming) GetType() *ContextRelationshipBaseType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ContextRelationshipIncoming) GetForeignKey() *string {
	if c == nil {
		return nil
	}
	return c.ForeignKey
}

func (c *ContextRelationshipIncoming) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *ContextRelationshipIncoming) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *ContextRelationshipIncoming) GetSourceContext() *ContextRelationshipIncomingSourceContext {
	if c == nil {
		return nil
	}
	return c.SourceContext
}

func (c *ContextRelationshipIncoming) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextRelationshipIncoming) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipIncoming) SetID(id *string) {
	c.ID = id
	c.require(contextRelationshipIncomingFieldID)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipIncoming) SetType(type_ *ContextRelationshipBaseType) {
	c.Type = type_
	c.require(contextRelationshipIncomingFieldType)
}

// SetForeignKey sets the ForeignKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipIncoming) SetForeignKey(foreignKey *string) {
	c.ForeignKey = foreignKey
	c.require(contextRelationshipIncomingFieldForeignKey)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipIncoming) SetName(name *string) {
	c.Name = name
	c.require(contextRelationshipIncomingFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipIncoming) SetDescription(description *string) {
	c.Description = description
	c.require(contextRelationshipIncomingFieldDescription)
}

// SetSourceContext sets the SourceContext field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipIncoming) SetSourceContext(sourceContext *ContextRelationshipIncomingSourceContext) {
	c.SourceContext = sourceContext
	c.require(contextRelationshipIncomingFieldSourceContext)
}

func (c *ContextRelationshipIncoming) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextRelationshipIncoming
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextRelationshipIncoming(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextRelationshipIncoming) MarshalJSON() ([]byte, error) {
	type embed ContextRelationshipIncoming
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextRelationshipIncoming) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	contextRelationshipIncomingSourceContextFieldID   = big.NewInt(1 << 0)
	contextRelationshipIncomingSourceContextFieldName = big.NewInt(1 << 1)
	contextRelationshipIncomingSourceContextFieldSlug = big.NewInt(1 << 2)
)

type ContextRelationshipIncomingSourceContext struct {
	ID   *string `json:"id,omitempty" url:"id,omitempty"`
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextRelationshipIncomingSourceContext) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *ContextRelationshipIncomingSourceContext) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *ContextRelationshipIncomingSourceContext) GetSlug() *string {
	if c == nil {
		return nil
	}
	return c.Slug
}

func (c *ContextRelationshipIncomingSourceContext) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextRelationshipIncomingSourceContext) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipIncomingSourceContext) SetID(id *string) {
	c.ID = id
	c.require(contextRelationshipIncomingSourceContextFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipIncomingSourceContext) SetName(name *string) {
	c.Name = name
	c.require(contextRelationshipIncomingSourceContextFieldName)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipIncomingSourceContext) SetSlug(slug *string) {
	c.Slug = slug
	c.require(contextRelationshipIncomingSourceContextFieldSlug)
}

func (c *ContextRelationshipIncomingSourceContext) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextRelationshipIncomingSourceContext
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextRelationshipIncomingSourceContext(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextRelationshipIncomingSourceContext) MarshalJSON() ([]byte, error) {
	type embed ContextRelationshipIncomingSourceContext
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextRelationshipIncomingSourceContext) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	contextRelationshipOutgoingFieldID            = big.NewInt(1 << 0)
	contextRelationshipOutgoingFieldType          = big.NewInt(1 << 1)
	contextRelationshipOutgoingFieldForeignKey    = big.NewInt(1 << 2)
	contextRelationshipOutgoingFieldName          = big.NewInt(1 << 3)
	contextRelationshipOutgoingFieldDescription   = big.NewInt(1 << 4)
	contextRelationshipOutgoingFieldTargetContext = big.NewInt(1 << 5)
)

type ContextRelationshipOutgoing struct {
	// The unique identifier for the relationship.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of relationship.
	Type *ContextRelationshipBaseType `json:"type,omitempty" url:"type,omitempty"`
	// The field key used as the foreign key.
	ForeignKey *string `json:"foreignKey,omitempty" url:"foreignKey,omitempty"`
	// Display name for the relationship.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Description of the relationship.
	Description   *string                                   `json:"description,omitempty" url:"description,omitempty"`
	TargetContext *ContextRelationshipOutgoingTargetContext `json:"targetContext,omitempty" url:"targetContext,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextRelationshipOutgoing) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *ContextRelationshipOutgoing) GetType() *ContextRelationshipBaseType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ContextRelationshipOutgoing) GetForeignKey() *string {
	if c == nil {
		return nil
	}
	return c.ForeignKey
}

func (c *ContextRelationshipOutgoing) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *ContextRelationshipOutgoing) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *ContextRelationshipOutgoing) GetTargetContext() *ContextRelationshipOutgoingTargetContext {
	if c == nil {
		return nil
	}
	return c.TargetContext
}

func (c *ContextRelationshipOutgoing) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextRelationshipOutgoing) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipOutgoing) SetID(id *string) {
	c.ID = id
	c.require(contextRelationshipOutgoingFieldID)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipOutgoing) SetType(type_ *ContextRelationshipBaseType) {
	c.Type = type_
	c.require(contextRelationshipOutgoingFieldType)
}

// SetForeignKey sets the ForeignKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipOutgoing) SetForeignKey(foreignKey *string) {
	c.ForeignKey = foreignKey
	c.require(contextRelationshipOutgoingFieldForeignKey)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipOutgoing) SetName(name *string) {
	c.Name = name
	c.require(contextRelationshipOutgoingFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipOutgoing) SetDescription(description *string) {
	c.Description = description
	c.require(contextRelationshipOutgoingFieldDescription)
}

// SetTargetContext sets the TargetContext field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipOutgoing) SetTargetContext(targetContext *ContextRelationshipOutgoingTargetContext) {
	c.TargetContext = targetContext
	c.require(contextRelationshipOutgoingFieldTargetContext)
}

func (c *ContextRelationshipOutgoing) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextRelationshipOutgoing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextRelationshipOutgoing(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextRelationshipOutgoing) MarshalJSON() ([]byte, error) {
	type embed ContextRelationshipOutgoing
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextRelationshipOutgoing) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	contextRelationshipOutgoingTargetContextFieldID   = big.NewInt(1 << 0)
	contextRelationshipOutgoingTargetContextFieldName = big.NewInt(1 << 1)
	contextRelationshipOutgoingTargetContextFieldSlug = big.NewInt(1 << 2)
)

type ContextRelationshipOutgoingTargetContext struct {
	ID   *string `json:"id,omitempty" url:"id,omitempty"`
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextRelationshipOutgoingTargetContext) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *ContextRelationshipOutgoingTargetContext) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *ContextRelationshipOutgoingTargetContext) GetSlug() *string {
	if c == nil {
		return nil
	}
	return c.Slug
}

func (c *ContextRelationshipOutgoingTargetContext) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextRelationshipOutgoingTargetContext) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipOutgoingTargetContext) SetID(id *string) {
	c.ID = id
	c.require(contextRelationshipOutgoingTargetContextFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipOutgoingTargetContext) SetName(name *string) {
	c.Name = name
	c.require(contextRelationshipOutgoingTargetContextFieldName)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipOutgoingTargetContext) SetSlug(slug *string) {
	c.Slug = slug
	c.require(contextRelationshipOutgoingTargetContextFieldSlug)
}

func (c *ContextRelationshipOutgoingTargetContext) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextRelationshipOutgoingTargetContext
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextRelationshipOutgoingTargetContext(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextRelationshipOutgoingTargetContext) MarshalJSON() ([]byte, error) {
	type embed ContextRelationshipOutgoingTargetContext
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextRelationshipOutgoingTargetContext) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	contextRelationshipsResponseFieldOutgoing = big.NewInt(1 << 0)
	contextRelationshipsResponseFieldIncoming = big.NewInt(1 << 1)
)

type ContextRelationshipsResponse struct {
	Outgoing []*ContextRelationshipOutgoing `json:"outgoing,omitempty" url:"outgoing,omitempty"`
	Incoming []*ContextRelationshipIncoming `json:"incoming,omitempty" url:"incoming,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextRelationshipsResponse) GetOutgoing() []*ContextRelationshipOutgoing {
	if c == nil {
		return nil
	}
	return c.Outgoing
}

func (c *ContextRelationshipsResponse) GetIncoming() []*ContextRelationshipIncoming {
	if c == nil {
		return nil
	}
	return c.Incoming
}

func (c *ContextRelationshipsResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextRelationshipsResponse) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetOutgoing sets the Outgoing field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipsResponse) SetOutgoing(outgoing []*ContextRelationshipOutgoing) {
	c.Outgoing = outgoing
	c.require(contextRelationshipsResponseFieldOutgoing)
}

// SetIncoming sets the Incoming field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextRelationshipsResponse) SetIncoming(incoming []*ContextRelationshipIncoming) {
	c.Incoming = incoming
	c.require(contextRelationshipsResponseFieldIncoming)
}

func (c *ContextRelationshipsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextRelationshipsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextRelationshipsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextRelationshipsResponse) MarshalJSON() ([]byte, error) {
	type embed ContextRelationshipsResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextRelationshipsResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The schema definition for a context.
var (
	contextSchemaFieldBase    = big.NewInt(1 << 0)
	contextSchemaFieldDerived = big.NewInt(1 << 1)
)

type ContextSchema struct {
	// User-defined base fields for the context.
	Base []*ContextSchemaField `json:"base,omitempty" url:"base,omitempty"`
	// Fields derived from bound rule/flow outputs.
	Derived []*ContextSchemaField `json:"derived,omitempty" url:"derived,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextSchema) GetBase() []*ContextSchemaField {
	if c == nil {
		return nil
	}
	return c.Base
}

func (c *ContextSchema) GetDerived() []*ContextSchemaField {
	if c == nil {
		return nil
	}
	return c.Derived
}

func (c *ContextSchema) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextSchema) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetBase sets the Base field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextSchema) SetBase(base []*ContextSchemaField) {
	c.Base = base
	c.require(contextSchemaFieldBase)
}

// SetDerived sets the Derived field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextSchema) SetDerived(derived []*ContextSchemaField) {
	c.Derived = derived
	c.require(contextSchemaFieldDerived)
}

func (c *ContextSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextSchema(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextSchema) MarshalJSON() ([]byte, error) {
	type embed ContextSchema
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextSchema) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A field definition within a context schema.
var (
	contextSchemaFieldFieldKey          = big.NewInt(1 << 0)
	contextSchemaFieldFieldName         = big.NewInt(1 << 1)
	contextSchemaFieldFieldDescription  = big.NewInt(1 << 2)
	contextSchemaFieldFieldType         = big.NewInt(1 << 3)
	contextSchemaFieldFieldDefaultValue = big.NewInt(1 << 4)
	contextSchemaFieldFieldDerived      = big.NewInt(1 << 5)
	contextSchemaFieldFieldSourceRule   = big.NewInt(1 << 6)
	contextSchemaFieldFieldSourceFlow   = big.NewInt(1 << 7)
	contextSchemaFieldFieldSourceField  = big.NewInt(1 << 8)
)

type ContextSchemaField struct {
	// The unique key for this field.
	Key *string `json:"key,omitempty" url:"key,omitempty"`
	// Display name for this field.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Description of this field.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Data type of this field. 'function' type fields compute values dynamically.
	Type *ContextSchemaFieldType `json:"type,omitempty" url:"type,omitempty"`
	// Default value for this field.
	DefaultValue interface{} `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`
	// Whether this field is derived from rule/flow outputs.
	Derived *bool `json:"derived,omitempty" url:"derived,omitempty"`
	// The rule ID that derives this field (if derived).
	SourceRule *string `json:"sourceRule,omitempty" url:"sourceRule,omitempty"`
	// The flow ID that derives this field (if derived).
	SourceFlow *string `json:"sourceFlow,omitempty" url:"sourceFlow,omitempty"`
	// The source field key in the rule/flow output.
	SourceField *string `json:"sourceField,omitempty" url:"sourceField,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextSchemaField) GetKey() *string {
	if c == nil {
		return nil
	}
	return c.Key
}

func (c *ContextSchemaField) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *ContextSchemaField) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *ContextSchemaField) GetType() *ContextSchemaFieldType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ContextSchemaField) GetDefaultValue() interface{} {
	if c == nil {
		return nil
	}
	return c.DefaultValue
}

func (c *ContextSchemaField) GetDerived() *bool {
	if c == nil {
		return nil
	}
	return c.Derived
}

func (c *ContextSchemaField) GetSourceRule() *string {
	if c == nil {
		return nil
	}
	return c.SourceRule
}

func (c *ContextSchemaField) GetSourceFlow() *string {
	if c == nil {
		return nil
	}
	return c.SourceFlow
}

func (c *ContextSchemaField) GetSourceField() *string {
	if c == nil {
		return nil
	}
	return c.SourceField
}

func (c *ContextSchemaField) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextSchemaField) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextSchemaField) SetKey(key *string) {
	c.Key = key
	c.require(contextSchemaFieldFieldKey)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextSchemaField) SetName(name *string) {
	c.Name = name
	c.require(contextSchemaFieldFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextSchemaField) SetDescription(description *string) {
	c.Description = description
	c.require(contextSchemaFieldFieldDescription)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextSchemaField) SetType(type_ *ContextSchemaFieldType) {
	c.Type = type_
	c.require(contextSchemaFieldFieldType)
}

// SetDefaultValue sets the DefaultValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextSchemaField) SetDefaultValue(defaultValue interface{}) {
	c.DefaultValue = defaultValue
	c.require(contextSchemaFieldFieldDefaultValue)
}

// SetDerived sets the Derived field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextSchemaField) SetDerived(derived *bool) {
	c.Derived = derived
	c.require(contextSchemaFieldFieldDerived)
}

// SetSourceRule sets the SourceRule field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextSchemaField) SetSourceRule(sourceRule *string) {
	c.SourceRule = sourceRule
	c.require(contextSchemaFieldFieldSourceRule)
}

// SetSourceFlow sets the SourceFlow field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextSchemaField) SetSourceFlow(sourceFlow *string) {
	c.SourceFlow = sourceFlow
	c.require(contextSchemaFieldFieldSourceFlow)
}

// SetSourceField sets the SourceField field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextSchemaField) SetSourceField(sourceField *string) {
	c.SourceField = sourceField
	c.require(contextSchemaFieldFieldSourceField)
}

func (c *ContextSchemaField) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextSchemaField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextSchemaField(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextSchemaField) MarshalJSON() ([]byte, error) {
	type embed ContextSchemaField
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextSchemaField) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Data type of this field. 'function' type fields compute values dynamically.
type ContextSchemaFieldType string

const (
	ContextSchemaFieldTypeString   ContextSchemaFieldType = "string"
	ContextSchemaFieldTypeNumber   ContextSchemaFieldType = "number"
	ContextSchemaFieldTypeBoolean  ContextSchemaFieldType = "boolean"
	ContextSchemaFieldTypeDate     ContextSchemaFieldType = "date"
	ContextSchemaFieldTypeList     ContextSchemaFieldType = "list"
	ContextSchemaFieldTypeFunction ContextSchemaFieldType = "function"
)

func NewContextSchemaFieldTypeFromString(s string) (ContextSchemaFieldType, error) {
	switch s {
	case "string":
		return ContextSchemaFieldTypeString, nil
	case "number":
		return ContextSchemaFieldTypeNumber, nil
	case "boolean":
		return ContextSchemaFieldTypeBoolean, nil
	case "date":
		return ContextSchemaFieldTypeDate, nil
	case "list":
		return ContextSchemaFieldTypeList, nil
	case "function":
		return ContextSchemaFieldTypeFunction, nil
	}
	var t ContextSchemaFieldType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ContextSchemaFieldType) Ptr() *ContextSchemaFieldType {
	return &c
}

type CreateContextResponse = *ContextDetail

type CreateRelationshipResponse = *ContextRelationshipOutgoing

var (
	createTestRequestFieldName     = big.NewInt(1 << 0)
	createTestRequestFieldRequest  = big.NewInt(1 << 1)
	createTestRequestFieldResponse = big.NewInt(1 << 2)
	createTestRequestFieldCritical = big.NewInt(1 << 3)
)

type CreateTestRequest struct {
	// The name of the test.
	Name string `json:"name" url:"name"`
	// The request object for the test.
	Request map[string]interface{} `json:"request" url:"request"`
	// The expected response object for the test.
	Response map[string]interface{} `json:"response" url:"response"`
	// Indicates whether the test is critical.
	Critical bool `json:"critical" url:"critical"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTestRequest) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CreateTestRequest) GetRequest() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Request
}

func (c *CreateTestRequest) GetResponse() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Response
}

func (c *CreateTestRequest) GetCritical() bool {
	if c == nil {
		return false
	}
	return c.Critical
}

func (c *CreateTestRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTestRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateTestRequest) SetName(name string) {
	c.Name = name
	c.require(createTestRequestFieldName)
}

// SetRequest sets the Request field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateTestRequest) SetRequest(request map[string]interface{}) {
	c.Request = request
	c.require(createTestRequestFieldRequest)
}

// SetResponse sets the Response field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateTestRequest) SetResponse(response map[string]interface{}) {
	c.Response = response
	c.require(createTestRequestFieldResponse)
}

// SetCritical sets the Critical field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateTestRequest) SetCritical(critical bool) {
	c.Critical = critical
	c.require(createTestRequestFieldCritical)
}

func (c *CreateTestRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTestRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTestRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTestRequest) MarshalJSON() ([]byte, error) {
	type embed CreateTestRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CreateTestRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Response after deleting a context.
var (
	deleteContextResponseFieldMessage                     = big.NewInt(1 << 0)
	deleteContextResponseFieldUnboundRules                = big.NewInt(1 << 1)
	deleteContextResponseFieldUnboundFlows                = big.NewInt(1 << 2)
	deleteContextResponseFieldPendingEvaluationsCancelled = big.NewInt(1 << 3)
)

type DeleteContextResponse struct {
	// Success message.
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Slugs of rules that were unbound from the deleted context.
	UnboundRules []string `json:"unbound_rules,omitempty" url:"unbound_rules,omitempty"`
	// Slugs of flows that were unbound from the deleted context.
	UnboundFlows []string `json:"unbound_flows,omitempty" url:"unbound_flows,omitempty"`
	// Number of pending evaluations that were cancelled when the context was deleted.
	PendingEvaluationsCancelled *int `json:"pending_evaluations_cancelled,omitempty" url:"pending_evaluations_cancelled,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteContextResponse) GetMessage() *string {
	if d == nil {
		return nil
	}
	return d.Message
}

func (d *DeleteContextResponse) GetUnboundRules() []string {
	if d == nil {
		return nil
	}
	return d.UnboundRules
}

func (d *DeleteContextResponse) GetUnboundFlows() []string {
	if d == nil {
		return nil
	}
	return d.UnboundFlows
}

func (d *DeleteContextResponse) GetPendingEvaluationsCancelled() *int {
	if d == nil {
		return nil
	}
	return d.PendingEvaluationsCancelled
}

func (d *DeleteContextResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteContextResponse) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteContextResponse) SetMessage(message *string) {
	d.Message = message
	d.require(deleteContextResponseFieldMessage)
}

// SetUnboundRules sets the UnboundRules field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteContextResponse) SetUnboundRules(unboundRules []string) {
	d.UnboundRules = unboundRules
	d.require(deleteContextResponseFieldUnboundRules)
}

// SetUnboundFlows sets the UnboundFlows field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteContextResponse) SetUnboundFlows(unboundFlows []string) {
	d.UnboundFlows = unboundFlows
	d.require(deleteContextResponseFieldUnboundFlows)
}

// SetPendingEvaluationsCancelled sets the PendingEvaluationsCancelled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteContextResponse) SetPendingEvaluationsCancelled(pendingEvaluationsCancelled *int) {
	d.PendingEvaluationsCancelled = pendingEvaluationsCancelled
	d.require(deleteContextResponseFieldPendingEvaluationsCancelled)
}

func (d *DeleteContextResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteContextResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteContextResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteContextResponse) MarshalJSON() ([]byte, error) {
	type embed DeleteContextResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DeleteContextResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	deleteRelationshipResponseFieldMessage = big.NewInt(1 << 0)
)

type DeleteRelationshipResponse struct {
	// Success message.
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteRelationshipResponse) GetMessage() *string {
	if d == nil {
		return nil
	}
	return d.Message
}

func (d *DeleteRelationshipResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteRelationshipResponse) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteRelationshipResponse) SetMessage(message *string) {
	d.Message = message
	d.require(deleteRelationshipResponseFieldMessage)
}

func (d *DeleteRelationshipResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteRelationshipResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteRelationshipResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteRelationshipResponse) MarshalJSON() ([]byte, error) {
	type embed DeleteRelationshipResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DeleteRelationshipResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Dynamic request payload for rule execution. Structure depends on rule configuration.
type DynamicRequestPayload = map[string]interface{}

// Dynamic response payload from rule execution. Structure depends on rule configuration.
type DynamicResponsePayload = map[string]interface{}

var (
	errorFieldError = big.NewInt(1 << 0)
)

type Error struct {
	// Error message
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Error) GetError() *string {
	if e == nil {
		return nil
	}
	return e.Error
}

func (e *Error) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Error) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetError sets the Error field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Error) SetError(error_ *string) {
	e.Error = error_
	e.require(errorFieldError)
}

func (e *Error) UnmarshalJSON(data []byte) error {
	type unmarshaler Error
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Error(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Error) MarshalJSON() ([]byte, error) {
	type embed Error
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *Error) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	flowBaseFieldID          = big.NewInt(1 << 0)
	flowBaseFieldName        = big.NewInt(1 << 1)
	flowBaseFieldDescription = big.NewInt(1 << 2)
	flowBaseFieldSlug        = big.NewInt(1 << 3)
)

type FlowBase struct {
	// The unique identifier for the flow.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the flow.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The description of the flow.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The unique slug for the flow used in API requests.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FlowBase) GetID() *string {
	if f == nil {
		return nil
	}
	return f.ID
}

func (f *FlowBase) GetName() *string {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *FlowBase) GetDescription() *string {
	if f == nil {
		return nil
	}
	return f.Description
}

func (f *FlowBase) GetSlug() *string {
	if f == nil {
		return nil
	}
	return f.Slug
}

func (f *FlowBase) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FlowBase) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowBase) SetID(id *string) {
	f.ID = id
	f.require(flowBaseFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowBase) SetName(name *string) {
	f.Name = name
	f.require(flowBaseFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowBase) SetDescription(description *string) {
	f.Description = description
	f.require(flowBaseFieldDescription)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowBase) SetSlug(slug *string) {
	f.Slug = slug
	f.require(flowBaseFieldSlug)
}

func (f *FlowBase) UnmarshalJSON(data []byte) error {
	type unmarshaler FlowBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FlowBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FlowBase) MarshalJSON() ([]byte, error) {
	type embed FlowBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FlowBase) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	flowDetailFieldID          = big.NewInt(1 << 0)
	flowDetailFieldName        = big.NewInt(1 << 1)
	flowDetailFieldDescription = big.NewInt(1 << 2)
	flowDetailFieldSlug        = big.NewInt(1 << 3)
	flowDetailFieldPublished   = big.NewInt(1 << 4)
	flowDetailFieldUpdatedAt   = big.NewInt(1 << 5)
	flowDetailFieldOriginRule  = big.NewInt(1 << 6)
	flowDetailFieldContext     = big.NewInt(1 << 7)
)

type FlowDetail struct {
	// The unique identifier for the flow.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the flow.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The description of the flow.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The unique slug for the flow used in API requests.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// Whether the flow is published.
	Published *bool `json:"published,omitempty" url:"published,omitempty"`
	// The date this flow was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The origin rule that this flow starts from. Flows execute starting from this rule's outputs.
	OriginRule *FlowDetailOriginRule `json:"origin_rule,omitempty" url:"origin_rule,omitempty"`
	// The context this flow is bound to (via its origin rule). Flows inherit context binding from their origin rule.
	Context *FlowDetailContext `json:"context,omitempty" url:"context,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FlowDetail) GetID() *string {
	if f == nil {
		return nil
	}
	return f.ID
}

func (f *FlowDetail) GetName() *string {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *FlowDetail) GetDescription() *string {
	if f == nil {
		return nil
	}
	return f.Description
}

func (f *FlowDetail) GetSlug() *string {
	if f == nil {
		return nil
	}
	return f.Slug
}

func (f *FlowDetail) GetPublished() *bool {
	if f == nil {
		return nil
	}
	return f.Published
}

func (f *FlowDetail) GetUpdatedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.UpdatedAt
}

func (f *FlowDetail) GetOriginRule() *FlowDetailOriginRule {
	if f == nil {
		return nil
	}
	return f.OriginRule
}

func (f *FlowDetail) GetContext() *FlowDetailContext {
	if f == nil {
		return nil
	}
	return f.Context
}

func (f *FlowDetail) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FlowDetail) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetail) SetID(id *string) {
	f.ID = id
	f.require(flowDetailFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetail) SetName(name *string) {
	f.Name = name
	f.require(flowDetailFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetail) SetDescription(description *string) {
	f.Description = description
	f.require(flowDetailFieldDescription)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetail) SetSlug(slug *string) {
	f.Slug = slug
	f.require(flowDetailFieldSlug)
}

// SetPublished sets the Published field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetail) SetPublished(published *bool) {
	f.Published = published
	f.require(flowDetailFieldPublished)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetail) SetUpdatedAt(updatedAt *time.Time) {
	f.UpdatedAt = updatedAt
	f.require(flowDetailFieldUpdatedAt)
}

// SetOriginRule sets the OriginRule field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetail) SetOriginRule(originRule *FlowDetailOriginRule) {
	f.OriginRule = originRule
	f.require(flowDetailFieldOriginRule)
}

// SetContext sets the Context field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetail) SetContext(context *FlowDetailContext) {
	f.Context = context
	f.require(flowDetailFieldContext)
}

func (f *FlowDetail) UnmarshalJSON(data []byte) error {
	type embed FlowDetail
	var unmarshaler = struct {
		embed
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FlowDetail(unmarshaler.embed)
	f.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FlowDetail) MarshalJSON() ([]byte, error) {
	type embed FlowDetail
	var marshaler = struct {
		embed
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*f),
		UpdatedAt: internal.NewOptionalDateTime(f.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FlowDetail) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The context this flow is bound to (via its origin rule). Flows inherit context binding from their origin rule.
var (
	flowDetailContextFieldID   = big.NewInt(1 << 0)
	flowDetailContextFieldName = big.NewInt(1 << 1)
	flowDetailContextFieldSlug = big.NewInt(1 << 2)
)

type FlowDetailContext struct {
	// The context ID.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The context name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The context slug.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FlowDetailContext) GetID() *string {
	if f == nil {
		return nil
	}
	return f.ID
}

func (f *FlowDetailContext) GetName() *string {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *FlowDetailContext) GetSlug() *string {
	if f == nil {
		return nil
	}
	return f.Slug
}

func (f *FlowDetailContext) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FlowDetailContext) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetailContext) SetID(id *string) {
	f.ID = id
	f.require(flowDetailContextFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetailContext) SetName(name *string) {
	f.Name = name
	f.require(flowDetailContextFieldName)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetailContext) SetSlug(slug *string) {
	f.Slug = slug
	f.require(flowDetailContextFieldSlug)
}

func (f *FlowDetailContext) UnmarshalJSON(data []byte) error {
	type unmarshaler FlowDetailContext
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FlowDetailContext(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FlowDetailContext) MarshalJSON() ([]byte, error) {
	type embed FlowDetailContext
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FlowDetailContext) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The origin rule that this flow starts from. Flows execute starting from this rule's outputs.
var (
	flowDetailOriginRuleFieldID   = big.NewInt(1 << 0)
	flowDetailOriginRuleFieldName = big.NewInt(1 << 1)
	flowDetailOriginRuleFieldSlug = big.NewInt(1 << 2)
)

type FlowDetailOriginRule struct {
	// The origin rule ID.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The origin rule name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The origin rule slug.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FlowDetailOriginRule) GetID() *string {
	if f == nil {
		return nil
	}
	return f.ID
}

func (f *FlowDetailOriginRule) GetName() *string {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *FlowDetailOriginRule) GetSlug() *string {
	if f == nil {
		return nil
	}
	return f.Slug
}

func (f *FlowDetailOriginRule) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FlowDetailOriginRule) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetailOriginRule) SetID(id *string) {
	f.ID = id
	f.require(flowDetailOriginRuleFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetailOriginRule) SetName(name *string) {
	f.Name = name
	f.require(flowDetailOriginRuleFieldName)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetailOriginRule) SetSlug(slug *string) {
	f.Slug = slug
	f.require(flowDetailOriginRuleFieldSlug)
}

func (f *FlowDetailOriginRule) UnmarshalJSON(data []byte) error {
	type unmarshaler FlowDetailOriginRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FlowDetailOriginRule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FlowDetailOriginRule) MarshalJSON() ([]byte, error) {
	type embed FlowDetailOriginRule
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FlowDetailOriginRule) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Error response when flow execution fails
var (
	flowExecutionErrorFieldError   = big.NewInt(1 << 0)
	flowExecutionErrorFieldNode    = big.NewInt(1 << 1)
	flowExecutionErrorFieldDetails = big.NewInt(1 << 2)
)

type FlowExecutionError struct {
	// Error message describing what went wrong during flow execution
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// Identifier of the node where the error occurred (if applicable)
	Node *string `json:"node,omitempty" url:"node,omitempty"`
	// Additional error details
	Details map[string]interface{} `json:"details,omitempty" url:"details,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FlowExecutionError) GetError() *string {
	if f == nil {
		return nil
	}
	return f.Error
}

func (f *FlowExecutionError) GetNode() *string {
	if f == nil {
		return nil
	}
	return f.Node
}

func (f *FlowExecutionError) GetDetails() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.Details
}

func (f *FlowExecutionError) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FlowExecutionError) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetError sets the Error field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowExecutionError) SetError(error_ *string) {
	f.Error = error_
	f.require(flowExecutionErrorFieldError)
}

// SetNode sets the Node field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowExecutionError) SetNode(node *string) {
	f.Node = node
	f.require(flowExecutionErrorFieldNode)
}

// SetDetails sets the Details field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowExecutionError) SetDetails(details map[string]interface{}) {
	f.Details = details
	f.require(flowExecutionErrorFieldDetails)
}

func (f *FlowExecutionError) UnmarshalJSON(data []byte) error {
	type unmarshaler FlowExecutionError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FlowExecutionError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FlowExecutionError) MarshalJSON() ([]byte, error) {
	type embed FlowExecutionError
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FlowExecutionError) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FlowListResponse = []*FlowDetail

var (
	folderFieldID          = big.NewInt(1 << 0)
	folderFieldName        = big.NewInt(1 << 1)
	folderFieldDescription = big.NewInt(1 << 2)
	folderFieldUpdatedAt   = big.NewInt(1 << 3)
)

type Folder struct {
	// Unique identifier for the folder.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Name of the folder.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Description of the folder.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Timestamp of when the folder was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *Folder) GetID() *string {
	if f == nil {
		return nil
	}
	return f.ID
}

func (f *Folder) GetName() *string {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *Folder) GetDescription() *string {
	if f == nil {
		return nil
	}
	return f.Description
}

func (f *Folder) GetUpdatedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.UpdatedAt
}

func (f *Folder) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Folder) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Folder) SetID(id *string) {
	f.ID = id
	f.require(folderFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Folder) SetName(name *string) {
	f.Name = name
	f.require(folderFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Folder) SetDescription(description *string) {
	f.Description = description
	f.require(folderFieldDescription)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Folder) SetUpdatedAt(updatedAt *time.Time) {
	f.UpdatedAt = updatedAt
	f.require(folderFieldUpdatedAt)
}

func (f *Folder) UnmarshalJSON(data []byte) error {
	type embed Folder
	var unmarshaler = struct {
		embed
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = Folder(unmarshaler.embed)
	f.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *Folder) MarshalJSON() ([]byte, error) {
	type embed Folder
	var marshaler = struct {
		embed
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*f),
		UpdatedAt: internal.NewOptionalDateTime(f.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *Folder) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FolderListResponse = []*Folder

var (
	ruleBaseFieldID          = big.NewInt(1 << 0)
	ruleBaseFieldName        = big.NewInt(1 << 1)
	ruleBaseFieldDescription = big.NewInt(1 << 2)
	ruleBaseFieldSlug        = big.NewInt(1 << 3)
)

type RuleBase struct {
	// The unique identifier for the rule.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the rule.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The description of the rule.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The unique slug for the rule used in API requests.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RuleBase) GetID() *string {
	if r == nil {
		return nil
	}
	return r.ID
}

func (r *RuleBase) GetName() *string {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *RuleBase) GetDescription() *string {
	if r == nil {
		return nil
	}
	return r.Description
}

func (r *RuleBase) GetSlug() *string {
	if r == nil {
		return nil
	}
	return r.Slug
}

func (r *RuleBase) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RuleBase) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleBase) SetID(id *string) {
	r.ID = id
	r.require(ruleBaseFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleBase) SetName(name *string) {
	r.Name = name
	r.require(ruleBaseFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleBase) SetDescription(description *string) {
	r.Description = description
	r.require(ruleBaseFieldDescription)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleBase) SetSlug(slug *string) {
	r.Slug = slug
	r.require(ruleBaseFieldSlug)
}

func (r *RuleBase) UnmarshalJSON(data []byte) error {
	type unmarshaler RuleBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RuleBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RuleBase) MarshalJSON() ([]byte, error) {
	type embed RuleBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RuleBase) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	ruleDetailFieldID             = big.NewInt(1 << 0)
	ruleDetailFieldName           = big.NewInt(1 << 1)
	ruleDetailFieldDescription    = big.NewInt(1 << 2)
	ruleDetailFieldSlug           = big.NewInt(1 << 3)
	ruleDetailFieldCreatedAt      = big.NewInt(1 << 4)
	ruleDetailFieldUpdatedAt      = big.NewInt(1 << 5)
	ruleDetailFieldFolder         = big.NewInt(1 << 6)
	ruleDetailFieldContext        = big.NewInt(1 << 7)
	ruleDetailFieldRequestSchema  = big.NewInt(1 << 8)
	ruleDetailFieldResponseSchema = big.NewInt(1 << 9)
)

type RuleDetail struct {
	// The unique identifier for the rule.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the rule.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The description of the rule.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The unique slug for the rule used in API requests.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// The date this rule was created.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The date this rule was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	Folder    *Folder    `json:"folder,omitempty" url:"folder,omitempty"`
	// The context this rule is bound to (if any). Rules bound to a context have their inputs/outputs mapped to context fields.
	Context *RuleDetailContext `json:"context,omitempty" url:"context,omitempty"`
	// The published request schema for the rule.
	RequestSchema []*SchemaField `json:"request_schema,omitempty" url:"request_schema,omitempty"`
	// The published response schema for the rule.
	ResponseSchema []*SchemaField `json:"response_schema,omitempty" url:"response_schema,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RuleDetail) GetID() *string {
	if r == nil {
		return nil
	}
	return r.ID
}

func (r *RuleDetail) GetName() *string {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *RuleDetail) GetDescription() *string {
	if r == nil {
		return nil
	}
	return r.Description
}

func (r *RuleDetail) GetSlug() *string {
	if r == nil {
		return nil
	}
	return r.Slug
}

func (r *RuleDetail) GetCreatedAt() *time.Time {
	if r == nil {
		return nil
	}
	return r.CreatedAt
}

func (r *RuleDetail) GetUpdatedAt() *time.Time {
	if r == nil {
		return nil
	}
	return r.UpdatedAt
}

func (r *RuleDetail) GetFolder() *Folder {
	if r == nil {
		return nil
	}
	return r.Folder
}

func (r *RuleDetail) GetContext() *RuleDetailContext {
	if r == nil {
		return nil
	}
	return r.Context
}

func (r *RuleDetail) GetRequestSchema() []*SchemaField {
	if r == nil {
		return nil
	}
	return r.RequestSchema
}

func (r *RuleDetail) GetResponseSchema() []*SchemaField {
	if r == nil {
		return nil
	}
	return r.ResponseSchema
}

func (r *RuleDetail) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RuleDetail) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetID(id *string) {
	r.ID = id
	r.require(ruleDetailFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetName(name *string) {
	r.Name = name
	r.require(ruleDetailFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetDescription(description *string) {
	r.Description = description
	r.require(ruleDetailFieldDescription)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetSlug(slug *string) {
	r.Slug = slug
	r.require(ruleDetailFieldSlug)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetCreatedAt(createdAt *time.Time) {
	r.CreatedAt = createdAt
	r.require(ruleDetailFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetUpdatedAt(updatedAt *time.Time) {
	r.UpdatedAt = updatedAt
	r.require(ruleDetailFieldUpdatedAt)
}

// SetFolder sets the Folder field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetFolder(folder *Folder) {
	r.Folder = folder
	r.require(ruleDetailFieldFolder)
}

// SetContext sets the Context field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetContext(context *RuleDetailContext) {
	r.Context = context
	r.require(ruleDetailFieldContext)
}

// SetRequestSchema sets the RequestSchema field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetRequestSchema(requestSchema []*SchemaField) {
	r.RequestSchema = requestSchema
	r.require(ruleDetailFieldRequestSchema)
}

// SetResponseSchema sets the ResponseSchema field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetResponseSchema(responseSchema []*SchemaField) {
	r.ResponseSchema = responseSchema
	r.require(ruleDetailFieldResponseSchema)
}

func (r *RuleDetail) UnmarshalJSON(data []byte) error {
	type embed RuleDetail
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RuleDetail(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	r.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RuleDetail) MarshalJSON() ([]byte, error) {
	type embed RuleDetail
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*r),
		CreatedAt: internal.NewOptionalDateTime(r.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(r.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RuleDetail) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The context this rule is bound to (if any). Rules bound to a context have their inputs/outputs mapped to context fields.
var (
	ruleDetailContextFieldID   = big.NewInt(1 << 0)
	ruleDetailContextFieldName = big.NewInt(1 << 1)
	ruleDetailContextFieldSlug = big.NewInt(1 << 2)
)

type RuleDetailContext struct {
	// The context ID.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The context name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The context slug.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RuleDetailContext) GetID() *string {
	if r == nil {
		return nil
	}
	return r.ID
}

func (r *RuleDetailContext) GetName() *string {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *RuleDetailContext) GetSlug() *string {
	if r == nil {
		return nil
	}
	return r.Slug
}

func (r *RuleDetailContext) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RuleDetailContext) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetailContext) SetID(id *string) {
	r.ID = id
	r.require(ruleDetailContextFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetailContext) SetName(name *string) {
	r.Name = name
	r.require(ruleDetailContextFieldName)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetailContext) SetSlug(slug *string) {
	r.Slug = slug
	r.require(ruleDetailContextFieldSlug)
}

func (r *RuleDetailContext) UnmarshalJSON(data []byte) error {
	type unmarshaler RuleDetailContext
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RuleDetailContext(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RuleDetailContext) MarshalJSON() ([]byte, error) {
	type embed RuleDetailContext
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RuleDetailContext) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The exported rule object containing all rule definition data.
type RuleExport = map[string]interface{}

type RuleListResponse = []*RuleDetail

var (
	schemaFieldFieldKey                  = big.NewInt(1 << 0)
	schemaFieldFieldShow                 = big.NewInt(1 << 1)
	schemaFieldFieldName                 = big.NewInt(1 << 2)
	schemaFieldFieldDescription          = big.NewInt(1 << 3)
	schemaFieldFieldType                 = big.NewInt(1 << 4)
	schemaFieldFieldDefaultValue         = big.NewInt(1 << 5)
	schemaFieldFieldDefaultComputedValue = big.NewInt(1 << 6)
	schemaFieldFieldTransform            = big.NewInt(1 << 7)
)

type SchemaField struct {
	// The unique key for this field.
	Key *string `json:"key,omitempty" url:"key,omitempty"`
	// Whether this field is visible in the UI.
	Show *bool `json:"show,omitempty" url:"show,omitempty"`
	// Display name for this field.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Description of this field.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Data type of this field.
	Type *SchemaFieldType `json:"type,omitempty" url:"type,omitempty"`
	// Default value for this field.
	DefaultValue *SchemaFieldDefaultValue `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`
	// Computed default value for this field.
	DefaultComputedValue *string `json:"defaultComputedValue,omitempty" url:"defaultComputedValue,omitempty"`
	// Transformation expression to apply to this field.
	Transform *string `json:"transform,omitempty" url:"transform,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SchemaField) GetKey() *string {
	if s == nil {
		return nil
	}
	return s.Key
}

func (s *SchemaField) GetShow() *bool {
	if s == nil {
		return nil
	}
	return s.Show
}

func (s *SchemaField) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SchemaField) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *SchemaField) GetType() *SchemaFieldType {
	if s == nil {
		return nil
	}
	return s.Type
}

func (s *SchemaField) GetDefaultValue() *SchemaFieldDefaultValue {
	if s == nil {
		return nil
	}
	return s.DefaultValue
}

func (s *SchemaField) GetDefaultComputedValue() *string {
	if s == nil {
		return nil
	}
	return s.DefaultComputedValue
}

func (s *SchemaField) GetTransform() *string {
	if s == nil {
		return nil
	}
	return s.Transform
}

func (s *SchemaField) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SchemaField) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemaField) SetKey(key *string) {
	s.Key = key
	s.require(schemaFieldFieldKey)
}

// SetShow sets the Show field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemaField) SetShow(show *bool) {
	s.Show = show
	s.require(schemaFieldFieldShow)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemaField) SetName(name *string) {
	s.Name = name
	s.require(schemaFieldFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemaField) SetDescription(description *string) {
	s.Description = description
	s.require(schemaFieldFieldDescription)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemaField) SetType(type_ *SchemaFieldType) {
	s.Type = type_
	s.require(schemaFieldFieldType)
}

// SetDefaultValue sets the DefaultValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemaField) SetDefaultValue(defaultValue *SchemaFieldDefaultValue) {
	s.DefaultValue = defaultValue
	s.require(schemaFieldFieldDefaultValue)
}

// SetDefaultComputedValue sets the DefaultComputedValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemaField) SetDefaultComputedValue(defaultComputedValue *string) {
	s.DefaultComputedValue = defaultComputedValue
	s.require(schemaFieldFieldDefaultComputedValue)
}

// SetTransform sets the Transform field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemaField) SetTransform(transform *string) {
	s.Transform = transform
	s.require(schemaFieldFieldTransform)
}

func (s *SchemaField) UnmarshalJSON(data []byte) error {
	type unmarshaler SchemaField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SchemaField(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SchemaField) MarshalJSON() ([]byte, error) {
	type embed SchemaField
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SchemaField) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Default value for this field.
type SchemaFieldDefaultValue struct {
	String           string
	Double           float64
	Boolean          bool
	StringUnknownMap map[string]interface{}
	UnknownList      []interface{}

	typ string
}

func (s *SchemaFieldDefaultValue) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SchemaFieldDefaultValue) GetDouble() float64 {
	if s == nil {
		return 0
	}
	return s.Double
}

func (s *SchemaFieldDefaultValue) GetBoolean() bool {
	if s == nil {
		return false
	}
	return s.Boolean
}

func (s *SchemaFieldDefaultValue) GetStringUnknownMap() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.StringUnknownMap
}

func (s *SchemaFieldDefaultValue) GetUnknownList() []interface{} {
	if s == nil {
		return nil
	}
	return s.UnknownList
}

func (s *SchemaFieldDefaultValue) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		s.typ = "Double"
		s.Double = valueDouble
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		s.typ = "Boolean"
		s.Boolean = valueBoolean
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		s.typ = "StringUnknownMap"
		s.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	var valueUnknownList []interface{}
	if err := json.Unmarshal(data, &valueUnknownList); err == nil {
		s.typ = "UnknownList"
		s.UnknownList = valueUnknownList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SchemaFieldDefaultValue) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Double" || s.Double != 0 {
		return json.Marshal(s.Double)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return json.Marshal(s.Boolean)
	}
	if s.typ == "StringUnknownMap" || s.StringUnknownMap != nil {
		return json.Marshal(s.StringUnknownMap)
	}
	if s.typ == "UnknownList" || s.UnknownList != nil {
		return json.Marshal(s.UnknownList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SchemaFieldDefaultValueVisitor interface {
	VisitString(string) error
	VisitDouble(float64) error
	VisitBoolean(bool) error
	VisitStringUnknownMap(map[string]interface{}) error
	VisitUnknownList([]interface{}) error
}

func (s *SchemaFieldDefaultValue) Accept(visitor SchemaFieldDefaultValueVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Double" || s.Double != 0 {
		return visitor.VisitDouble(s.Double)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return visitor.VisitBoolean(s.Boolean)
	}
	if s.typ == "StringUnknownMap" || s.StringUnknownMap != nil {
		return visitor.VisitStringUnknownMap(s.StringUnknownMap)
	}
	if s.typ == "UnknownList" || s.UnknownList != nil {
		return visitor.VisitUnknownList(s.UnknownList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// Data type of this field.
type SchemaFieldType string

const (
	SchemaFieldTypeString  SchemaFieldType = "string"
	SchemaFieldTypeNumber  SchemaFieldType = "number"
	SchemaFieldTypeBoolean SchemaFieldType = "boolean"
	SchemaFieldTypeObject  SchemaFieldType = "object"
	SchemaFieldTypeArray   SchemaFieldType = "array"
)

func NewSchemaFieldTypeFromString(s string) (SchemaFieldType, error) {
	switch s {
	case "string":
		return SchemaFieldTypeString, nil
	case "number":
		return SchemaFieldTypeNumber, nil
	case "boolean":
		return SchemaFieldTypeBoolean, nil
	case "object":
		return SchemaFieldTypeObject, nil
	case "array":
		return SchemaFieldTypeArray, nil
	}
	var t SchemaFieldType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SchemaFieldType) Ptr() *SchemaFieldType {
	return &s
}

var (
	successMessageFieldMessage = big.NewInt(1 << 0)
)

type SuccessMessage struct {
	// Success message
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SuccessMessage) GetMessage() *string {
	if s == nil {
		return nil
	}
	return s.Message
}

func (s *SuccessMessage) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SuccessMessage) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SuccessMessage) SetMessage(message *string) {
	s.Message = message
	s.require(successMessageFieldMessage)
}

func (s *SuccessMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler SuccessMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SuccessMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SuccessMessage) MarshalJSON() ([]byte, error) {
	type embed SuccessMessage
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SuccessMessage) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	testFieldID           = big.NewInt(1 << 0)
	testFieldName         = big.NewInt(1 << 1)
	testFieldRequest      = big.NewInt(1 << 2)
	testFieldResponse     = big.NewInt(1 << 3)
	testFieldCritical     = big.NewInt(1 << 4)
	testFieldError        = big.NewInt(1 << 5)
	testFieldSuccess      = big.NewInt(1 << 6)
	testFieldTestState    = big.NewInt(1 << 7)
	testFieldLastExecuted = big.NewInt(1 << 8)
)

type Test struct {
	// Unique identifier for the test.
	ID string `json:"id" url:"id"`
	// The name of the test.
	Name string `json:"name" url:"name"`
	// The request object for the test.
	Request map[string]interface{} `json:"request" url:"request"`
	// The expected response object for the test.
	Response map[string]interface{} `json:"response" url:"response"`
	// Indicates whether the test is critical.
	Critical bool `json:"critical" url:"critical"`
	// Indicates if the test resulted in an error.
	Error bool `json:"error" url:"error"`
	// Indicates if the test was successful.
	Success bool `json:"success" url:"success"`
	// The state of the test after execution.
	TestState *TestTestState `json:"testState,omitempty" url:"testState,omitempty"`
	// The timestamp when the test was last executed.
	LastExecuted *time.Time `json:"lastExecuted,omitempty" url:"lastExecuted,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Test) GetID() string {
	if t == nil {
		return ""
	}
	return t.ID
}

func (t *Test) GetName() string {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *Test) GetRequest() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Request
}

func (t *Test) GetResponse() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Response
}

func (t *Test) GetCritical() bool {
	if t == nil {
		return false
	}
	return t.Critical
}

func (t *Test) GetError() bool {
	if t == nil {
		return false
	}
	return t.Error
}

func (t *Test) GetSuccess() bool {
	if t == nil {
		return false
	}
	return t.Success
}

func (t *Test) GetTestState() *TestTestState {
	if t == nil {
		return nil
	}
	return t.TestState
}

func (t *Test) GetLastExecuted() *time.Time {
	if t == nil {
		return nil
	}
	return t.LastExecuted
}

func (t *Test) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Test) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetID(id string) {
	t.ID = id
	t.require(testFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetName(name string) {
	t.Name = name
	t.require(testFieldName)
}

// SetRequest sets the Request field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetRequest(request map[string]interface{}) {
	t.Request = request
	t.require(testFieldRequest)
}

// SetResponse sets the Response field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetResponse(response map[string]interface{}) {
	t.Response = response
	t.require(testFieldResponse)
}

// SetCritical sets the Critical field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetCritical(critical bool) {
	t.Critical = critical
	t.require(testFieldCritical)
}

// SetError sets the Error field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetError(error_ bool) {
	t.Error = error_
	t.require(testFieldError)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetSuccess(success bool) {
	t.Success = success
	t.require(testFieldSuccess)
}

// SetTestState sets the TestState field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetTestState(testState *TestTestState) {
	t.TestState = testState
	t.require(testFieldTestState)
}

// SetLastExecuted sets the LastExecuted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetLastExecuted(lastExecuted *time.Time) {
	t.LastExecuted = lastExecuted
	t.require(testFieldLastExecuted)
}

func (t *Test) UnmarshalJSON(data []byte) error {
	type embed Test
	var unmarshaler = struct {
		embed
		LastExecuted *internal.DateTime `json:"lastExecuted,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Test(unmarshaler.embed)
	t.LastExecuted = unmarshaler.LastExecuted.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Test) MarshalJSON() ([]byte, error) {
	type embed Test
	var marshaler = struct {
		embed
		LastExecuted *internal.DateTime `json:"lastExecuted,omitempty"`
	}{
		embed:        embed(*t),
		LastExecuted: internal.NewOptionalDateTime(t.LastExecuted),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Test) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TestListResponse = []*Test

// The state of the test after execution.
var (
	testTestStateFieldDuration        = big.NewInt(1 << 0)
	testTestStateFieldResponse        = big.NewInt(1 << 1)
	testTestStateFieldConditions      = big.NewInt(1 << 2)
	testTestStateFieldHTTPStatus      = big.NewInt(1 << 3)
	testTestStateFieldSuccessIdxs     = big.NewInt(1 << 4)
	testTestStateFieldEvaluationError = big.NewInt(1 << 5)
)

type TestTestState struct {
	// Execution time in seconds
	Duration *float64 `json:"duration,omitempty" url:"duration,omitempty"`
	// Actual response returned
	Response   map[string]interface{}   `json:"response,omitempty" url:"response,omitempty"`
	Conditions []map[string]interface{} `json:"conditions,omitempty" url:"conditions,omitempty"`
	// HTTP status code returned
	HTTPStatus  *int  `json:"httpStatus,omitempty" url:"httpStatus,omitempty"`
	SuccessIdxs []int `json:"successIdxs,omitempty" url:"successIdxs,omitempty"`
	// Error message or flag indicating if evaluation error occurred
	EvaluationError *TestTestStateEvaluationError `json:"evaluationError,omitempty" url:"evaluationError,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TestTestState) GetDuration() *float64 {
	if t == nil {
		return nil
	}
	return t.Duration
}

func (t *TestTestState) GetResponse() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Response
}

func (t *TestTestState) GetConditions() []map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Conditions
}

func (t *TestTestState) GetHTTPStatus() *int {
	if t == nil {
		return nil
	}
	return t.HTTPStatus
}

func (t *TestTestState) GetSuccessIdxs() []int {
	if t == nil {
		return nil
	}
	return t.SuccessIdxs
}

func (t *TestTestState) GetEvaluationError() *TestTestStateEvaluationError {
	if t == nil {
		return nil
	}
	return t.EvaluationError
}

func (t *TestTestState) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TestTestState) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetDuration sets the Duration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TestTestState) SetDuration(duration *float64) {
	t.Duration = duration
	t.require(testTestStateFieldDuration)
}

// SetResponse sets the Response field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TestTestState) SetResponse(response map[string]interface{}) {
	t.Response = response
	t.require(testTestStateFieldResponse)
}

// SetConditions sets the Conditions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TestTestState) SetConditions(conditions []map[string]interface{}) {
	t.Conditions = conditions
	t.require(testTestStateFieldConditions)
}

// SetHTTPStatus sets the HTTPStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TestTestState) SetHTTPStatus(httpStatus *int) {
	t.HTTPStatus = httpStatus
	t.require(testTestStateFieldHTTPStatus)
}

// SetSuccessIdxs sets the SuccessIdxs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TestTestState) SetSuccessIdxs(successIdxs []int) {
	t.SuccessIdxs = successIdxs
	t.require(testTestStateFieldSuccessIdxs)
}

// SetEvaluationError sets the EvaluationError field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TestTestState) SetEvaluationError(evaluationError *TestTestStateEvaluationError) {
	t.EvaluationError = evaluationError
	t.require(testTestStateFieldEvaluationError)
}

func (t *TestTestState) UnmarshalJSON(data []byte) error {
	type unmarshaler TestTestState
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TestTestState(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TestTestState) MarshalJSON() ([]byte, error) {
	type embed TestTestState
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TestTestState) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Error message or flag indicating if evaluation error occurred
type TestTestStateEvaluationError struct {
	Boolean bool
	String  string

	typ string
}

func (t *TestTestStateEvaluationError) GetBoolean() bool {
	if t == nil {
		return false
	}
	return t.Boolean
}

func (t *TestTestStateEvaluationError) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TestTestStateEvaluationError) UnmarshalJSON(data []byte) error {
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		t.typ = "Boolean"
		t.Boolean = valueBoolean
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TestTestStateEvaluationError) MarshalJSON() ([]byte, error) {
	if t.typ == "Boolean" || t.Boolean != false {
		return json.Marshal(t.Boolean)
	}
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TestTestStateEvaluationErrorVisitor interface {
	VisitBoolean(bool) error
	VisitString(string) error
}

func (t *TestTestStateEvaluationError) Accept(visitor TestTestStateEvaluationErrorVisitor) error {
	if t.typ == "Boolean" || t.Boolean != false {
		return visitor.VisitBoolean(t.Boolean)
	}
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

type UpdateContextResponse = *ContextDetail

var (
	userGroupFieldID          = big.NewInt(1 << 0)
	userGroupFieldName        = big.NewInt(1 << 1)
	userGroupFieldDescription = big.NewInt(1 << 2)
	userGroupFieldMembers     = big.NewInt(1 << 3)
)

type UserGroup struct {
	// Unique identifier of the user group.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Name of the user group.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Description of the user group.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// List of member emails in the user group.
	Members []string `json:"members,omitempty" url:"members,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserGroup) GetID() *string {
	if u == nil {
		return nil
	}
	return u.ID
}

func (u *UserGroup) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UserGroup) GetDescription() *string {
	if u == nil {
		return nil
	}
	return u.Description
}

func (u *UserGroup) GetMembers() []string {
	if u == nil {
		return nil
	}
	return u.Members
}

func (u *UserGroup) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserGroup) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserGroup) SetID(id *string) {
	u.ID = id
	u.require(userGroupFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserGroup) SetName(name *string) {
	u.Name = name
	u.require(userGroupFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserGroup) SetDescription(description *string) {
	u.Description = description
	u.require(userGroupFieldDescription)
}

// SetMembers sets the Members field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserGroup) SetMembers(members []string) {
	u.Members = members
	u.require(userGroupFieldMembers)
}

func (u *UserGroup) UnmarshalJSON(data []byte) error {
	type unmarshaler UserGroup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserGroup(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserGroup) MarshalJSON() ([]byte, error) {
	type embed UserGroup
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserGroup) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserGroupListResponse = []*UserGroup

// System limits for dynamic values
var (
	valueLimitsFieldMaxKeys        = big.NewInt(1 << 0)
	valueLimitsFieldMaxValueLength = big.NewInt(1 << 1)
	valueLimitsFieldMaxTotalSize   = big.NewInt(1 << 2)
	valueLimitsFieldMaxKeyLength   = big.NewInt(1 << 3)
)

type ValueLimits struct {
	// Maximum number of value keys per user
	MaxKeys *int `json:"MAX_KEYS,omitempty" url:"MAX_KEYS,omitempty"`
	// Maximum length of a single value in characters
	MaxValueLength *int `json:"MAX_VALUE_LENGTH,omitempty" url:"MAX_VALUE_LENGTH,omitempty"`
	// Maximum total size of all values in bytes
	MaxTotalSize *int `json:"MAX_TOTAL_SIZE,omitempty" url:"MAX_TOTAL_SIZE,omitempty"`
	// Maximum length of a key name
	MaxKeyLength *int `json:"MAX_KEY_LENGTH,omitempty" url:"MAX_KEY_LENGTH,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *ValueLimits) GetMaxKeys() *int {
	if v == nil {
		return nil
	}
	return v.MaxKeys
}

func (v *ValueLimits) GetMaxValueLength() *int {
	if v == nil {
		return nil
	}
	return v.MaxValueLength
}

func (v *ValueLimits) GetMaxTotalSize() *int {
	if v == nil {
		return nil
	}
	return v.MaxTotalSize
}

func (v *ValueLimits) GetMaxKeyLength() *int {
	if v == nil {
		return nil
	}
	return v.MaxKeyLength
}

func (v *ValueLimits) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ValueLimits) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetMaxKeys sets the MaxKeys field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *ValueLimits) SetMaxKeys(maxKeys *int) {
	v.MaxKeys = maxKeys
	v.require(valueLimitsFieldMaxKeys)
}

// SetMaxValueLength sets the MaxValueLength field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *ValueLimits) SetMaxValueLength(maxValueLength *int) {
	v.MaxValueLength = maxValueLength
	v.require(valueLimitsFieldMaxValueLength)
}

// SetMaxTotalSize sets the MaxTotalSize field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *ValueLimits) SetMaxTotalSize(maxTotalSize *int) {
	v.MaxTotalSize = maxTotalSize
	v.require(valueLimitsFieldMaxTotalSize)
}

// SetMaxKeyLength sets the MaxKeyLength field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *ValueLimits) SetMaxKeyLength(maxKeyLength *int) {
	v.MaxKeyLength = maxKeyLength
	v.require(valueLimitsFieldMaxKeyLength)
}

func (v *ValueLimits) UnmarshalJSON(data []byte) error {
	type unmarshaler ValueLimits
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValueLimits(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValueLimits) MarshalJSON() ([]byte, error) {
	type embed ValueLimits
	var marshaler = struct {
		embed
	}{
		embed: embed(*v),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, v.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (v *ValueLimits) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}
