// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "sdk/internal"
)

// Dynamic request payload for rule execution. Structure depends on rule configuration.
type DynamicRequestPayload = map[string]interface{}

// Dynamic response payload from rule execution. Structure depends on rule configuration.
type DynamicResponsePayload = map[string]interface{}

type Error struct {
	// Error message
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Error) GetError() *string {
	if e == nil {
		return nil
	}
	return e.Error
}

func (e *Error) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Error) UnmarshalJSON(data []byte) error {
	type unmarshaler Error
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Error(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Error) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Error response when flow execution fails
type FlowExecutionError struct {
	// Error message describing what went wrong during flow execution
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// Identifier of the node where the error occurred (if applicable)
	Node *string `json:"node,omitempty" url:"node,omitempty"`
	// Additional error details
	Details map[string]interface{} `json:"details,omitempty" url:"details,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FlowExecutionError) GetError() *string {
	if f == nil {
		return nil
	}
	return f.Error
}

func (f *FlowExecutionError) GetNode() *string {
	if f == nil {
		return nil
	}
	return f.Node
}

func (f *FlowExecutionError) GetDetails() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.Details
}

func (f *FlowExecutionError) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FlowExecutionError) UnmarshalJSON(data []byte) error {
	type unmarshaler FlowExecutionError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FlowExecutionError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FlowExecutionError) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type SuccessMessage struct {
	// Success message
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SuccessMessage) GetMessage() *string {
	if s == nil {
		return nil
	}
	return s.Message
}

func (s *SuccessMessage) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SuccessMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler SuccessMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SuccessMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SuccessMessage) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// System limits for dynamic values
type ValueLimits struct {
	// Maximum number of value keys per user
	MaxKeys *int `json:"MAX_KEYS,omitempty" url:"MAX_KEYS,omitempty"`
	// Maximum length of a single value in characters
	MaxValueLength *int `json:"MAX_VALUE_LENGTH,omitempty" url:"MAX_VALUE_LENGTH,omitempty"`
	// Maximum total size of all values in bytes
	MaxTotalSize *int `json:"MAX_TOTAL_SIZE,omitempty" url:"MAX_TOTAL_SIZE,omitempty"`
	// Maximum length of a key name
	MaxKeyLength *int `json:"MAX_KEY_LENGTH,omitempty" url:"MAX_KEY_LENGTH,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *ValueLimits) GetMaxKeys() *int {
	if v == nil {
		return nil
	}
	return v.MaxKeys
}

func (v *ValueLimits) GetMaxValueLength() *int {
	if v == nil {
		return nil
	}
	return v.MaxValueLength
}

func (v *ValueLimits) GetMaxTotalSize() *int {
	if v == nil {
		return nil
	}
	return v.MaxTotalSize
}

func (v *ValueLimits) GetMaxKeyLength() *int {
	if v == nil {
		return nil
	}
	return v.MaxKeyLength
}

func (v *ValueLimits) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ValueLimits) UnmarshalJSON(data []byte) error {
	type unmarshaler ValueLimits
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValueLimits(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValueLimits) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}
