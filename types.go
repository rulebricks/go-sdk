// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"
	internal "sdk/internal"
	time "time"
)

var (
	createTestRequestFieldName     = big.NewInt(1 << 0)
	createTestRequestFieldRequest  = big.NewInt(1 << 1)
	createTestRequestFieldResponse = big.NewInt(1 << 2)
	createTestRequestFieldCritical = big.NewInt(1 << 3)
)

type CreateTestRequest struct {
	// The name of the test.
	Name string `json:"name" url:"name"`
	// The request object for the test.
	Request map[string]interface{} `json:"request" url:"request"`
	// The expected response object for the test.
	Response map[string]interface{} `json:"response" url:"response"`
	// Indicates whether the test is critical.
	Critical bool `json:"critical" url:"critical"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTestRequest) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CreateTestRequest) GetRequest() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Request
}

func (c *CreateTestRequest) GetResponse() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Response
}

func (c *CreateTestRequest) GetCritical() bool {
	if c == nil {
		return false
	}
	return c.Critical
}

func (c *CreateTestRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTestRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateTestRequest) SetName(name string) {
	c.Name = name
	c.require(createTestRequestFieldName)
}

// SetRequest sets the Request field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateTestRequest) SetRequest(request map[string]interface{}) {
	c.Request = request
	c.require(createTestRequestFieldRequest)
}

// SetResponse sets the Response field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateTestRequest) SetResponse(response map[string]interface{}) {
	c.Response = response
	c.require(createTestRequestFieldResponse)
}

// SetCritical sets the Critical field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateTestRequest) SetCritical(critical bool) {
	c.Critical = critical
	c.require(createTestRequestFieldCritical)
}

func (c *CreateTestRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTestRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTestRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTestRequest) MarshalJSON() ([]byte, error) {
	type embed CreateTestRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CreateTestRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Dynamic request payload for rule execution. Structure depends on rule configuration.
type DynamicRequestPayload = map[string]interface{}

// Dynamic response payload from rule execution. Structure depends on rule configuration.
type DynamicResponsePayload = map[string]interface{}

var (
	errorFieldError = big.NewInt(1 << 0)
)

type Error struct {
	// Error message
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Error) GetError() *string {
	if e == nil {
		return nil
	}
	return e.Error
}

func (e *Error) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Error) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetError sets the Error field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Error) SetError(error_ *string) {
	e.Error = error_
	e.require(errorFieldError)
}

func (e *Error) UnmarshalJSON(data []byte) error {
	type unmarshaler Error
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Error(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Error) MarshalJSON() ([]byte, error) {
	type embed Error
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *Error) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	flowBaseFieldID          = big.NewInt(1 << 0)
	flowBaseFieldName        = big.NewInt(1 << 1)
	flowBaseFieldDescription = big.NewInt(1 << 2)
	flowBaseFieldSlug        = big.NewInt(1 << 3)
)

type FlowBase struct {
	// The unique identifier for the flow.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the flow.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The description of the flow.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The unique slug for the flow used in API requests.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FlowBase) GetID() *string {
	if f == nil {
		return nil
	}
	return f.ID
}

func (f *FlowBase) GetName() *string {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *FlowBase) GetDescription() *string {
	if f == nil {
		return nil
	}
	return f.Description
}

func (f *FlowBase) GetSlug() *string {
	if f == nil {
		return nil
	}
	return f.Slug
}

func (f *FlowBase) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FlowBase) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowBase) SetID(id *string) {
	f.ID = id
	f.require(flowBaseFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowBase) SetName(name *string) {
	f.Name = name
	f.require(flowBaseFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowBase) SetDescription(description *string) {
	f.Description = description
	f.require(flowBaseFieldDescription)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowBase) SetSlug(slug *string) {
	f.Slug = slug
	f.require(flowBaseFieldSlug)
}

func (f *FlowBase) UnmarshalJSON(data []byte) error {
	type unmarshaler FlowBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FlowBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FlowBase) MarshalJSON() ([]byte, error) {
	type embed FlowBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FlowBase) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	flowDetailFieldID          = big.NewInt(1 << 0)
	flowDetailFieldName        = big.NewInt(1 << 1)
	flowDetailFieldDescription = big.NewInt(1 << 2)
	flowDetailFieldSlug        = big.NewInt(1 << 3)
	flowDetailFieldPublished   = big.NewInt(1 << 4)
	flowDetailFieldUpdatedAt   = big.NewInt(1 << 5)
)

type FlowDetail struct {
	// The unique identifier for the flow.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the flow.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The description of the flow.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The unique slug for the flow used in API requests.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// Whether the flow is published.
	Published *bool `json:"published,omitempty" url:"published,omitempty"`
	// The date this flow was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FlowDetail) GetID() *string {
	if f == nil {
		return nil
	}
	return f.ID
}

func (f *FlowDetail) GetName() *string {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *FlowDetail) GetDescription() *string {
	if f == nil {
		return nil
	}
	return f.Description
}

func (f *FlowDetail) GetSlug() *string {
	if f == nil {
		return nil
	}
	return f.Slug
}

func (f *FlowDetail) GetPublished() *bool {
	if f == nil {
		return nil
	}
	return f.Published
}

func (f *FlowDetail) GetUpdatedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.UpdatedAt
}

func (f *FlowDetail) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FlowDetail) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetail) SetID(id *string) {
	f.ID = id
	f.require(flowDetailFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetail) SetName(name *string) {
	f.Name = name
	f.require(flowDetailFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetail) SetDescription(description *string) {
	f.Description = description
	f.require(flowDetailFieldDescription)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetail) SetSlug(slug *string) {
	f.Slug = slug
	f.require(flowDetailFieldSlug)
}

// SetPublished sets the Published field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetail) SetPublished(published *bool) {
	f.Published = published
	f.require(flowDetailFieldPublished)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowDetail) SetUpdatedAt(updatedAt *time.Time) {
	f.UpdatedAt = updatedAt
	f.require(flowDetailFieldUpdatedAt)
}

func (f *FlowDetail) UnmarshalJSON(data []byte) error {
	type embed FlowDetail
	var unmarshaler = struct {
		embed
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FlowDetail(unmarshaler.embed)
	f.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FlowDetail) MarshalJSON() ([]byte, error) {
	type embed FlowDetail
	var marshaler = struct {
		embed
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*f),
		UpdatedAt: internal.NewOptionalDateTime(f.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FlowDetail) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Error response when flow execution fails
var (
	flowExecutionErrorFieldError   = big.NewInt(1 << 0)
	flowExecutionErrorFieldNode    = big.NewInt(1 << 1)
	flowExecutionErrorFieldDetails = big.NewInt(1 << 2)
)

type FlowExecutionError struct {
	// Error message describing what went wrong during flow execution
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// Identifier of the node where the error occurred (if applicable)
	Node *string `json:"node,omitempty" url:"node,omitempty"`
	// Additional error details
	Details map[string]interface{} `json:"details,omitempty" url:"details,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FlowExecutionError) GetError() *string {
	if f == nil {
		return nil
	}
	return f.Error
}

func (f *FlowExecutionError) GetNode() *string {
	if f == nil {
		return nil
	}
	return f.Node
}

func (f *FlowExecutionError) GetDetails() map[string]interface{} {
	if f == nil {
		return nil
	}
	return f.Details
}

func (f *FlowExecutionError) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FlowExecutionError) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetError sets the Error field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowExecutionError) SetError(error_ *string) {
	f.Error = error_
	f.require(flowExecutionErrorFieldError)
}

// SetNode sets the Node field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowExecutionError) SetNode(node *string) {
	f.Node = node
	f.require(flowExecutionErrorFieldNode)
}

// SetDetails sets the Details field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FlowExecutionError) SetDetails(details map[string]interface{}) {
	f.Details = details
	f.require(flowExecutionErrorFieldDetails)
}

func (f *FlowExecutionError) UnmarshalJSON(data []byte) error {
	type unmarshaler FlowExecutionError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FlowExecutionError(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FlowExecutionError) MarshalJSON() ([]byte, error) {
	type embed FlowExecutionError
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FlowExecutionError) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FlowListResponse = []*FlowDetail

var (
	folderFieldID          = big.NewInt(1 << 0)
	folderFieldName        = big.NewInt(1 << 1)
	folderFieldDescription = big.NewInt(1 << 2)
	folderFieldUpdatedAt   = big.NewInt(1 << 3)
)

type Folder struct {
	// Unique identifier for the folder.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Name of the folder.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Description of the folder.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Timestamp of when the folder was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *Folder) GetID() *string {
	if f == nil {
		return nil
	}
	return f.ID
}

func (f *Folder) GetName() *string {
	if f == nil {
		return nil
	}
	return f.Name
}

func (f *Folder) GetDescription() *string {
	if f == nil {
		return nil
	}
	return f.Description
}

func (f *Folder) GetUpdatedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.UpdatedAt
}

func (f *Folder) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Folder) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Folder) SetID(id *string) {
	f.ID = id
	f.require(folderFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Folder) SetName(name *string) {
	f.Name = name
	f.require(folderFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Folder) SetDescription(description *string) {
	f.Description = description
	f.require(folderFieldDescription)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Folder) SetUpdatedAt(updatedAt *time.Time) {
	f.UpdatedAt = updatedAt
	f.require(folderFieldUpdatedAt)
}

func (f *Folder) UnmarshalJSON(data []byte) error {
	type embed Folder
	var unmarshaler = struct {
		embed
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = Folder(unmarshaler.embed)
	f.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *Folder) MarshalJSON() ([]byte, error) {
	type embed Folder
	var marshaler = struct {
		embed
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*f),
		UpdatedAt: internal.NewOptionalDateTime(f.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *Folder) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FolderListResponse = []*Folder

var (
	ruleBaseFieldID          = big.NewInt(1 << 0)
	ruleBaseFieldName        = big.NewInt(1 << 1)
	ruleBaseFieldDescription = big.NewInt(1 << 2)
	ruleBaseFieldSlug        = big.NewInt(1 << 3)
)

type RuleBase struct {
	// The unique identifier for the rule.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the rule.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The description of the rule.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The unique slug for the rule used in API requests.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RuleBase) GetID() *string {
	if r == nil {
		return nil
	}
	return r.ID
}

func (r *RuleBase) GetName() *string {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *RuleBase) GetDescription() *string {
	if r == nil {
		return nil
	}
	return r.Description
}

func (r *RuleBase) GetSlug() *string {
	if r == nil {
		return nil
	}
	return r.Slug
}

func (r *RuleBase) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RuleBase) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleBase) SetID(id *string) {
	r.ID = id
	r.require(ruleBaseFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleBase) SetName(name *string) {
	r.Name = name
	r.require(ruleBaseFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleBase) SetDescription(description *string) {
	r.Description = description
	r.require(ruleBaseFieldDescription)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleBase) SetSlug(slug *string) {
	r.Slug = slug
	r.require(ruleBaseFieldSlug)
}

func (r *RuleBase) UnmarshalJSON(data []byte) error {
	type unmarshaler RuleBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RuleBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RuleBase) MarshalJSON() ([]byte, error) {
	type embed RuleBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RuleBase) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	ruleDetailFieldID             = big.NewInt(1 << 0)
	ruleDetailFieldName           = big.NewInt(1 << 1)
	ruleDetailFieldDescription    = big.NewInt(1 << 2)
	ruleDetailFieldSlug           = big.NewInt(1 << 3)
	ruleDetailFieldCreatedAt      = big.NewInt(1 << 4)
	ruleDetailFieldFolder         = big.NewInt(1 << 5)
	ruleDetailFieldRequestSchema  = big.NewInt(1 << 6)
	ruleDetailFieldResponseSchema = big.NewInt(1 << 7)
)

type RuleDetail struct {
	// The unique identifier for the rule.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the rule.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The description of the rule.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The unique slug for the rule used in API requests.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// The date this rule was created.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	Folder    *Folder    `json:"folder,omitempty" url:"folder,omitempty"`
	// The published request schema for the rule.
	RequestSchema []*SchemaField `json:"request_schema,omitempty" url:"request_schema,omitempty"`
	// The published response schema for the rule.
	ResponseSchema []*SchemaField `json:"response_schema,omitempty" url:"response_schema,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RuleDetail) GetID() *string {
	if r == nil {
		return nil
	}
	return r.ID
}

func (r *RuleDetail) GetName() *string {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *RuleDetail) GetDescription() *string {
	if r == nil {
		return nil
	}
	return r.Description
}

func (r *RuleDetail) GetSlug() *string {
	if r == nil {
		return nil
	}
	return r.Slug
}

func (r *RuleDetail) GetCreatedAt() *time.Time {
	if r == nil {
		return nil
	}
	return r.CreatedAt
}

func (r *RuleDetail) GetFolder() *Folder {
	if r == nil {
		return nil
	}
	return r.Folder
}

func (r *RuleDetail) GetRequestSchema() []*SchemaField {
	if r == nil {
		return nil
	}
	return r.RequestSchema
}

func (r *RuleDetail) GetResponseSchema() []*SchemaField {
	if r == nil {
		return nil
	}
	return r.ResponseSchema
}

func (r *RuleDetail) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RuleDetail) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetID(id *string) {
	r.ID = id
	r.require(ruleDetailFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetName(name *string) {
	r.Name = name
	r.require(ruleDetailFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetDescription(description *string) {
	r.Description = description
	r.require(ruleDetailFieldDescription)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetSlug(slug *string) {
	r.Slug = slug
	r.require(ruleDetailFieldSlug)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetCreatedAt(createdAt *time.Time) {
	r.CreatedAt = createdAt
	r.require(ruleDetailFieldCreatedAt)
}

// SetFolder sets the Folder field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetFolder(folder *Folder) {
	r.Folder = folder
	r.require(ruleDetailFieldFolder)
}

// SetRequestSchema sets the RequestSchema field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetRequestSchema(requestSchema []*SchemaField) {
	r.RequestSchema = requestSchema
	r.require(ruleDetailFieldRequestSchema)
}

// SetResponseSchema sets the ResponseSchema field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleDetail) SetResponseSchema(responseSchema []*SchemaField) {
	r.ResponseSchema = responseSchema
	r.require(ruleDetailFieldResponseSchema)
}

func (r *RuleDetail) UnmarshalJSON(data []byte) error {
	type embed RuleDetail
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RuleDetail(unmarshaler.embed)
	r.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RuleDetail) MarshalJSON() ([]byte, error) {
	type embed RuleDetail
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
	}{
		embed:     embed(*r),
		CreatedAt: internal.NewOptionalDateTime(r.CreatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RuleDetail) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The exported rule object containing all rule definition data.
type RuleExport = map[string]interface{}

type RuleListResponse = []*RuleDetail

var (
	schemaFieldFieldKey                  = big.NewInt(1 << 0)
	schemaFieldFieldShow                 = big.NewInt(1 << 1)
	schemaFieldFieldName                 = big.NewInt(1 << 2)
	schemaFieldFieldDescription          = big.NewInt(1 << 3)
	schemaFieldFieldType                 = big.NewInt(1 << 4)
	schemaFieldFieldDefaultValue         = big.NewInt(1 << 5)
	schemaFieldFieldDefaultComputedValue = big.NewInt(1 << 6)
	schemaFieldFieldTransform            = big.NewInt(1 << 7)
)

type SchemaField struct {
	// The unique key for this field.
	Key *string `json:"key,omitempty" url:"key,omitempty"`
	// Whether this field is visible in the UI.
	Show *bool `json:"show,omitempty" url:"show,omitempty"`
	// Display name for this field.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Description of this field.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Data type of this field.
	Type *SchemaFieldType `json:"type,omitempty" url:"type,omitempty"`
	// Default value for this field.
	DefaultValue *SchemaFieldDefaultValue `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`
	// Computed default value for this field.
	DefaultComputedValue *string `json:"defaultComputedValue,omitempty" url:"defaultComputedValue,omitempty"`
	// Transformation expression to apply to this field.
	Transform *string `json:"transform,omitempty" url:"transform,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SchemaField) GetKey() *string {
	if s == nil {
		return nil
	}
	return s.Key
}

func (s *SchemaField) GetShow() *bool {
	if s == nil {
		return nil
	}
	return s.Show
}

func (s *SchemaField) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SchemaField) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *SchemaField) GetType() *SchemaFieldType {
	if s == nil {
		return nil
	}
	return s.Type
}

func (s *SchemaField) GetDefaultValue() *SchemaFieldDefaultValue {
	if s == nil {
		return nil
	}
	return s.DefaultValue
}

func (s *SchemaField) GetDefaultComputedValue() *string {
	if s == nil {
		return nil
	}
	return s.DefaultComputedValue
}

func (s *SchemaField) GetTransform() *string {
	if s == nil {
		return nil
	}
	return s.Transform
}

func (s *SchemaField) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SchemaField) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemaField) SetKey(key *string) {
	s.Key = key
	s.require(schemaFieldFieldKey)
}

// SetShow sets the Show field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemaField) SetShow(show *bool) {
	s.Show = show
	s.require(schemaFieldFieldShow)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemaField) SetName(name *string) {
	s.Name = name
	s.require(schemaFieldFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemaField) SetDescription(description *string) {
	s.Description = description
	s.require(schemaFieldFieldDescription)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemaField) SetType(type_ *SchemaFieldType) {
	s.Type = type_
	s.require(schemaFieldFieldType)
}

// SetDefaultValue sets the DefaultValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemaField) SetDefaultValue(defaultValue *SchemaFieldDefaultValue) {
	s.DefaultValue = defaultValue
	s.require(schemaFieldFieldDefaultValue)
}

// SetDefaultComputedValue sets the DefaultComputedValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemaField) SetDefaultComputedValue(defaultComputedValue *string) {
	s.DefaultComputedValue = defaultComputedValue
	s.require(schemaFieldFieldDefaultComputedValue)
}

// SetTransform sets the Transform field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SchemaField) SetTransform(transform *string) {
	s.Transform = transform
	s.require(schemaFieldFieldTransform)
}

func (s *SchemaField) UnmarshalJSON(data []byte) error {
	type unmarshaler SchemaField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SchemaField(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SchemaField) MarshalJSON() ([]byte, error) {
	type embed SchemaField
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SchemaField) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Default value for this field.
type SchemaFieldDefaultValue struct {
	String           string
	Double           float64
	Boolean          bool
	StringUnknownMap map[string]interface{}
	UnknownList      []interface{}

	typ string
}

func (s *SchemaFieldDefaultValue) GetString() string {
	if s == nil {
		return ""
	}
	return s.String
}

func (s *SchemaFieldDefaultValue) GetDouble() float64 {
	if s == nil {
		return 0
	}
	return s.Double
}

func (s *SchemaFieldDefaultValue) GetBoolean() bool {
	if s == nil {
		return false
	}
	return s.Boolean
}

func (s *SchemaFieldDefaultValue) GetStringUnknownMap() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.StringUnknownMap
}

func (s *SchemaFieldDefaultValue) GetUnknownList() []interface{} {
	if s == nil {
		return nil
	}
	return s.UnknownList
}

func (s *SchemaFieldDefaultValue) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typ = "String"
		s.String = valueString
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		s.typ = "Double"
		s.Double = valueDouble
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		s.typ = "Boolean"
		s.Boolean = valueBoolean
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		s.typ = "StringUnknownMap"
		s.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	var valueUnknownList []interface{}
	if err := json.Unmarshal(data, &valueUnknownList); err == nil {
		s.typ = "UnknownList"
		s.UnknownList = valueUnknownList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SchemaFieldDefaultValue) MarshalJSON() ([]byte, error) {
	if s.typ == "String" || s.String != "" {
		return json.Marshal(s.String)
	}
	if s.typ == "Double" || s.Double != 0 {
		return json.Marshal(s.Double)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return json.Marshal(s.Boolean)
	}
	if s.typ == "StringUnknownMap" || s.StringUnknownMap != nil {
		return json.Marshal(s.StringUnknownMap)
	}
	if s.typ == "UnknownList" || s.UnknownList != nil {
		return json.Marshal(s.UnknownList)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type SchemaFieldDefaultValueVisitor interface {
	VisitString(string) error
	VisitDouble(float64) error
	VisitBoolean(bool) error
	VisitStringUnknownMap(map[string]interface{}) error
	VisitUnknownList([]interface{}) error
}

func (s *SchemaFieldDefaultValue) Accept(visitor SchemaFieldDefaultValueVisitor) error {
	if s.typ == "String" || s.String != "" {
		return visitor.VisitString(s.String)
	}
	if s.typ == "Double" || s.Double != 0 {
		return visitor.VisitDouble(s.Double)
	}
	if s.typ == "Boolean" || s.Boolean != false {
		return visitor.VisitBoolean(s.Boolean)
	}
	if s.typ == "StringUnknownMap" || s.StringUnknownMap != nil {
		return visitor.VisitStringUnknownMap(s.StringUnknownMap)
	}
	if s.typ == "UnknownList" || s.UnknownList != nil {
		return visitor.VisitUnknownList(s.UnknownList)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

// Data type of this field.
type SchemaFieldType string

const (
	SchemaFieldTypeString  SchemaFieldType = "string"
	SchemaFieldTypeNumber  SchemaFieldType = "number"
	SchemaFieldTypeBoolean SchemaFieldType = "boolean"
	SchemaFieldTypeObject  SchemaFieldType = "object"
	SchemaFieldTypeArray   SchemaFieldType = "array"
)

func NewSchemaFieldTypeFromString(s string) (SchemaFieldType, error) {
	switch s {
	case "string":
		return SchemaFieldTypeString, nil
	case "number":
		return SchemaFieldTypeNumber, nil
	case "boolean":
		return SchemaFieldTypeBoolean, nil
	case "object":
		return SchemaFieldTypeObject, nil
	case "array":
		return SchemaFieldTypeArray, nil
	}
	var t SchemaFieldType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SchemaFieldType) Ptr() *SchemaFieldType {
	return &s
}

var (
	successMessageFieldMessage = big.NewInt(1 << 0)
)

type SuccessMessage struct {
	// Success message
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SuccessMessage) GetMessage() *string {
	if s == nil {
		return nil
	}
	return s.Message
}

func (s *SuccessMessage) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SuccessMessage) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SuccessMessage) SetMessage(message *string) {
	s.Message = message
	s.require(successMessageFieldMessage)
}

func (s *SuccessMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler SuccessMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SuccessMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SuccessMessage) MarshalJSON() ([]byte, error) {
	type embed SuccessMessage
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SuccessMessage) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	testFieldID           = big.NewInt(1 << 0)
	testFieldName         = big.NewInt(1 << 1)
	testFieldRequest      = big.NewInt(1 << 2)
	testFieldResponse     = big.NewInt(1 << 3)
	testFieldCritical     = big.NewInt(1 << 4)
	testFieldError        = big.NewInt(1 << 5)
	testFieldSuccess      = big.NewInt(1 << 6)
	testFieldTestState    = big.NewInt(1 << 7)
	testFieldLastExecuted = big.NewInt(1 << 8)
)

type Test struct {
	// Unique identifier for the test.
	ID string `json:"id" url:"id"`
	// The name of the test.
	Name string `json:"name" url:"name"`
	// The request object for the test.
	Request map[string]interface{} `json:"request" url:"request"`
	// The expected response object for the test.
	Response map[string]interface{} `json:"response" url:"response"`
	// Indicates whether the test is critical.
	Critical bool `json:"critical" url:"critical"`
	// Indicates if the test resulted in an error.
	Error bool `json:"error" url:"error"`
	// Indicates if the test was successful.
	Success bool `json:"success" url:"success"`
	// The state of the test after execution.
	TestState *TestTestState `json:"testState,omitempty" url:"testState,omitempty"`
	// The timestamp when the test was last executed.
	LastExecuted *time.Time `json:"lastExecuted,omitempty" url:"lastExecuted,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Test) GetID() string {
	if t == nil {
		return ""
	}
	return t.ID
}

func (t *Test) GetName() string {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *Test) GetRequest() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Request
}

func (t *Test) GetResponse() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Response
}

func (t *Test) GetCritical() bool {
	if t == nil {
		return false
	}
	return t.Critical
}

func (t *Test) GetError() bool {
	if t == nil {
		return false
	}
	return t.Error
}

func (t *Test) GetSuccess() bool {
	if t == nil {
		return false
	}
	return t.Success
}

func (t *Test) GetTestState() *TestTestState {
	if t == nil {
		return nil
	}
	return t.TestState
}

func (t *Test) GetLastExecuted() *time.Time {
	if t == nil {
		return nil
	}
	return t.LastExecuted
}

func (t *Test) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Test) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetID(id string) {
	t.ID = id
	t.require(testFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetName(name string) {
	t.Name = name
	t.require(testFieldName)
}

// SetRequest sets the Request field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetRequest(request map[string]interface{}) {
	t.Request = request
	t.require(testFieldRequest)
}

// SetResponse sets the Response field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetResponse(response map[string]interface{}) {
	t.Response = response
	t.require(testFieldResponse)
}

// SetCritical sets the Critical field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetCritical(critical bool) {
	t.Critical = critical
	t.require(testFieldCritical)
}

// SetError sets the Error field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetError(error_ bool) {
	t.Error = error_
	t.require(testFieldError)
}

// SetSuccess sets the Success field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetSuccess(success bool) {
	t.Success = success
	t.require(testFieldSuccess)
}

// SetTestState sets the TestState field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetTestState(testState *TestTestState) {
	t.TestState = testState
	t.require(testFieldTestState)
}

// SetLastExecuted sets the LastExecuted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Test) SetLastExecuted(lastExecuted *time.Time) {
	t.LastExecuted = lastExecuted
	t.require(testFieldLastExecuted)
}

func (t *Test) UnmarshalJSON(data []byte) error {
	type embed Test
	var unmarshaler = struct {
		embed
		LastExecuted *internal.DateTime `json:"lastExecuted,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = Test(unmarshaler.embed)
	t.LastExecuted = unmarshaler.LastExecuted.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Test) MarshalJSON() ([]byte, error) {
	type embed Test
	var marshaler = struct {
		embed
		LastExecuted *internal.DateTime `json:"lastExecuted,omitempty"`
	}{
		embed:        embed(*t),
		LastExecuted: internal.NewOptionalDateTime(t.LastExecuted),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Test) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TestListResponse = []*Test

// The state of the test after execution.
var (
	testTestStateFieldDuration        = big.NewInt(1 << 0)
	testTestStateFieldResponse        = big.NewInt(1 << 1)
	testTestStateFieldConditions      = big.NewInt(1 << 2)
	testTestStateFieldHTTPStatus      = big.NewInt(1 << 3)
	testTestStateFieldSuccessIdxs     = big.NewInt(1 << 4)
	testTestStateFieldEvaluationError = big.NewInt(1 << 5)
)

type TestTestState struct {
	// Execution time in seconds
	Duration *float64 `json:"duration,omitempty" url:"duration,omitempty"`
	// Actual response returned
	Response   map[string]interface{}   `json:"response,omitempty" url:"response,omitempty"`
	Conditions []map[string]interface{} `json:"conditions,omitempty" url:"conditions,omitempty"`
	// HTTP status code returned
	HTTPStatus  *int  `json:"httpStatus,omitempty" url:"httpStatus,omitempty"`
	SuccessIdxs []int `json:"successIdxs,omitempty" url:"successIdxs,omitempty"`
	// Error message or flag indicating if evaluation error occurred
	EvaluationError *TestTestStateEvaluationError `json:"evaluationError,omitempty" url:"evaluationError,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TestTestState) GetDuration() *float64 {
	if t == nil {
		return nil
	}
	return t.Duration
}

func (t *TestTestState) GetResponse() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Response
}

func (t *TestTestState) GetConditions() []map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Conditions
}

func (t *TestTestState) GetHTTPStatus() *int {
	if t == nil {
		return nil
	}
	return t.HTTPStatus
}

func (t *TestTestState) GetSuccessIdxs() []int {
	if t == nil {
		return nil
	}
	return t.SuccessIdxs
}

func (t *TestTestState) GetEvaluationError() *TestTestStateEvaluationError {
	if t == nil {
		return nil
	}
	return t.EvaluationError
}

func (t *TestTestState) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TestTestState) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetDuration sets the Duration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TestTestState) SetDuration(duration *float64) {
	t.Duration = duration
	t.require(testTestStateFieldDuration)
}

// SetResponse sets the Response field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TestTestState) SetResponse(response map[string]interface{}) {
	t.Response = response
	t.require(testTestStateFieldResponse)
}

// SetConditions sets the Conditions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TestTestState) SetConditions(conditions []map[string]interface{}) {
	t.Conditions = conditions
	t.require(testTestStateFieldConditions)
}

// SetHTTPStatus sets the HTTPStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TestTestState) SetHTTPStatus(httpStatus *int) {
	t.HTTPStatus = httpStatus
	t.require(testTestStateFieldHTTPStatus)
}

// SetSuccessIdxs sets the SuccessIdxs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TestTestState) SetSuccessIdxs(successIdxs []int) {
	t.SuccessIdxs = successIdxs
	t.require(testTestStateFieldSuccessIdxs)
}

// SetEvaluationError sets the EvaluationError field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TestTestState) SetEvaluationError(evaluationError *TestTestStateEvaluationError) {
	t.EvaluationError = evaluationError
	t.require(testTestStateFieldEvaluationError)
}

func (t *TestTestState) UnmarshalJSON(data []byte) error {
	type unmarshaler TestTestState
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TestTestState(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TestTestState) MarshalJSON() ([]byte, error) {
	type embed TestTestState
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TestTestState) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Error message or flag indicating if evaluation error occurred
type TestTestStateEvaluationError struct {
	Boolean bool
	String  string

	typ string
}

func (t *TestTestStateEvaluationError) GetBoolean() bool {
	if t == nil {
		return false
	}
	return t.Boolean
}

func (t *TestTestStateEvaluationError) GetString() string {
	if t == nil {
		return ""
	}
	return t.String
}

func (t *TestTestStateEvaluationError) UnmarshalJSON(data []byte) error {
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		t.typ = "Boolean"
		t.Boolean = valueBoolean
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typ = "String"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TestTestStateEvaluationError) MarshalJSON() ([]byte, error) {
	if t.typ == "Boolean" || t.Boolean != false {
		return json.Marshal(t.Boolean)
	}
	if t.typ == "String" || t.String != "" {
		return json.Marshal(t.String)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TestTestStateEvaluationErrorVisitor interface {
	VisitBoolean(bool) error
	VisitString(string) error
}

func (t *TestTestStateEvaluationError) Accept(visitor TestTestStateEvaluationErrorVisitor) error {
	if t.typ == "Boolean" || t.Boolean != false {
		return visitor.VisitBoolean(t.Boolean)
	}
	if t.typ == "String" || t.String != "" {
		return visitor.VisitString(t.String)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

var (
	userGroupFieldID          = big.NewInt(1 << 0)
	userGroupFieldName        = big.NewInt(1 << 1)
	userGroupFieldDescription = big.NewInt(1 << 2)
	userGroupFieldMembers     = big.NewInt(1 << 3)
)

type UserGroup struct {
	// Unique identifier of the user group.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Name of the user group.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Description of the user group.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// List of member emails in the user group.
	Members []string `json:"members,omitempty" url:"members,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserGroup) GetID() *string {
	if u == nil {
		return nil
	}
	return u.ID
}

func (u *UserGroup) GetName() *string {
	if u == nil {
		return nil
	}
	return u.Name
}

func (u *UserGroup) GetDescription() *string {
	if u == nil {
		return nil
	}
	return u.Description
}

func (u *UserGroup) GetMembers() []string {
	if u == nil {
		return nil
	}
	return u.Members
}

func (u *UserGroup) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserGroup) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserGroup) SetID(id *string) {
	u.ID = id
	u.require(userGroupFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserGroup) SetName(name *string) {
	u.Name = name
	u.require(userGroupFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserGroup) SetDescription(description *string) {
	u.Description = description
	u.require(userGroupFieldDescription)
}

// SetMembers sets the Members field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserGroup) SetMembers(members []string) {
	u.Members = members
	u.require(userGroupFieldMembers)
}

func (u *UserGroup) UnmarshalJSON(data []byte) error {
	type unmarshaler UserGroup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserGroup(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserGroup) MarshalJSON() ([]byte, error) {
	type embed UserGroup
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserGroup) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserGroupListResponse = []*UserGroup

// System limits for dynamic values
var (
	valueLimitsFieldMaxKeys        = big.NewInt(1 << 0)
	valueLimitsFieldMaxValueLength = big.NewInt(1 << 1)
	valueLimitsFieldMaxTotalSize   = big.NewInt(1 << 2)
	valueLimitsFieldMaxKeyLength   = big.NewInt(1 << 3)
)

type ValueLimits struct {
	// Maximum number of value keys per user
	MaxKeys *int `json:"MAX_KEYS,omitempty" url:"MAX_KEYS,omitempty"`
	// Maximum length of a single value in characters
	MaxValueLength *int `json:"MAX_VALUE_LENGTH,omitempty" url:"MAX_VALUE_LENGTH,omitempty"`
	// Maximum total size of all values in bytes
	MaxTotalSize *int `json:"MAX_TOTAL_SIZE,omitempty" url:"MAX_TOTAL_SIZE,omitempty"`
	// Maximum length of a key name
	MaxKeyLength *int `json:"MAX_KEY_LENGTH,omitempty" url:"MAX_KEY_LENGTH,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *ValueLimits) GetMaxKeys() *int {
	if v == nil {
		return nil
	}
	return v.MaxKeys
}

func (v *ValueLimits) GetMaxValueLength() *int {
	if v == nil {
		return nil
	}
	return v.MaxValueLength
}

func (v *ValueLimits) GetMaxTotalSize() *int {
	if v == nil {
		return nil
	}
	return v.MaxTotalSize
}

func (v *ValueLimits) GetMaxKeyLength() *int {
	if v == nil {
		return nil
	}
	return v.MaxKeyLength
}

func (v *ValueLimits) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *ValueLimits) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetMaxKeys sets the MaxKeys field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *ValueLimits) SetMaxKeys(maxKeys *int) {
	v.MaxKeys = maxKeys
	v.require(valueLimitsFieldMaxKeys)
}

// SetMaxValueLength sets the MaxValueLength field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *ValueLimits) SetMaxValueLength(maxValueLength *int) {
	v.MaxValueLength = maxValueLength
	v.require(valueLimitsFieldMaxValueLength)
}

// SetMaxTotalSize sets the MaxTotalSize field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *ValueLimits) SetMaxTotalSize(maxTotalSize *int) {
	v.MaxTotalSize = maxTotalSize
	v.require(valueLimitsFieldMaxTotalSize)
}

// SetMaxKeyLength sets the MaxKeyLength field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *ValueLimits) SetMaxKeyLength(maxKeyLength *int) {
	v.MaxKeyLength = maxKeyLength
	v.require(valueLimitsFieldMaxKeyLength)
}

func (v *ValueLimits) UnmarshalJSON(data []byte) error {
	type unmarshaler ValueLimits
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = ValueLimits(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *ValueLimits) MarshalJSON() ([]byte, error) {
	type embed ValueLimits
	var marshaler = struct {
		embed
	}{
		embed: embed(*v),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, v.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (v *ValueLimits) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}
