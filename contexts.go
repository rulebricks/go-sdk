// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"
	internal "sdk/internal"
	time "time"
)

var (
	cascadeContextRequestFieldSlug     = big.NewInt(1 << 0)
	cascadeContextRequestFieldInstance = big.NewInt(1 << 1)
	cascadeContextRequestFieldMaxDepth = big.NewInt(1 << 2)
)

type CascadeContextRequest struct {
	// The unique slug for the context.
	Slug string `json:"-" url:"-"`
	// The unique identifier for the context instance.
	Instance string `json:"-" url:"-"`
	// Maximum depth for cascading evaluations.
	MaxDepth *int `json:"maxDepth,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CascadeContextRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CascadeContextRequest) SetSlug(slug string) {
	c.Slug = slug
	c.require(cascadeContextRequestFieldSlug)
}

// SetInstance sets the Instance field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CascadeContextRequest) SetInstance(instance string) {
	c.Instance = instance
	c.require(cascadeContextRequestFieldInstance)
}

// SetMaxDepth sets the MaxDepth field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CascadeContextRequest) SetMaxDepth(maxDepth *int) {
	c.MaxDepth = maxDepth
	c.require(cascadeContextRequestFieldMaxDepth)
}

var (
	deleteInstanceContextsRequestFieldSlug     = big.NewInt(1 << 0)
	deleteInstanceContextsRequestFieldInstance = big.NewInt(1 << 1)
)

type DeleteInstanceContextsRequest struct {
	// The unique slug for the context.
	Slug string `json:"-" url:"-"`
	// The unique identifier for the context instance.
	Instance string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (d *DeleteInstanceContextsRequest) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteInstanceContextsRequest) SetSlug(slug string) {
	d.Slug = slug
	d.require(deleteInstanceContextsRequestFieldSlug)
}

// SetInstance sets the Instance field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteInstanceContextsRequest) SetInstance(instance string) {
	d.Instance = instance
	d.require(deleteInstanceContextsRequestFieldInstance)
}

var (
	solveContextFlowRequestFieldSlug           = big.NewInt(1 << 0)
	solveContextFlowRequestFieldInstance       = big.NewInt(1 << 1)
	solveContextFlowRequestFieldFlowSlug       = big.NewInt(1 << 2)
	solveContextFlowRequestFieldAdditionalData = big.NewInt(1 << 3)
	solveContextFlowRequestFieldPersist        = big.NewInt(1 << 4)
)

type SolveContextFlowRequest struct {
	// The unique slug for the context.
	Slug string `json:"-" url:"-"`
	// The unique identifier for the context instance.
	Instance string `json:"-" url:"-"`
	// The unique slug for the flow.
	FlowSlug string `json:"-" url:"-"`
	// Additional data to merge with instance state for flow execution.
	AdditionalData map[string]interface{} `json:"additionalData,omitempty" url:"-"`
	// Whether to persist derived outputs to the instance.
	Persist *bool `json:"persist,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *SolveContextFlowRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextFlowRequest) SetSlug(slug string) {
	s.Slug = slug
	s.require(solveContextFlowRequestFieldSlug)
}

// SetInstance sets the Instance field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextFlowRequest) SetInstance(instance string) {
	s.Instance = instance
	s.require(solveContextFlowRequestFieldInstance)
}

// SetFlowSlug sets the FlowSlug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextFlowRequest) SetFlowSlug(flowSlug string) {
	s.FlowSlug = flowSlug
	s.require(solveContextFlowRequestFieldFlowSlug)
}

// SetAdditionalData sets the AdditionalData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextFlowRequest) SetAdditionalData(additionalData map[string]interface{}) {
	s.AdditionalData = additionalData
	s.require(solveContextFlowRequestFieldAdditionalData)
}

// SetPersist sets the Persist field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextFlowRequest) SetPersist(persist *bool) {
	s.Persist = persist
	s.require(solveContextFlowRequestFieldPersist)
}

var (
	getHistoryContextsRequestFieldSlug     = big.NewInt(1 << 0)
	getHistoryContextsRequestFieldInstance = big.NewInt(1 << 1)
	getHistoryContextsRequestFieldField    = big.NewInt(1 << 2)
	getHistoryContextsRequestFieldLimit    = big.NewInt(1 << 3)
)

type GetHistoryContextsRequest struct {
	// The unique slug for the context.
	Slug string `json:"-" url:"-"`
	// The unique identifier for the context instance.
	Instance string `json:"-" url:"-"`
	// Filter history to a specific field.
	Field *string `json:"-" url:"field,omitempty"`
	// Maximum number of history entries to return.
	Limit *int `json:"-" url:"limit,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (g *GetHistoryContextsRequest) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetHistoryContextsRequest) SetSlug(slug string) {
	g.Slug = slug
	g.require(getHistoryContextsRequestFieldSlug)
}

// SetInstance sets the Instance field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetHistoryContextsRequest) SetInstance(instance string) {
	g.Instance = instance
	g.require(getHistoryContextsRequestFieldInstance)
}

// SetField sets the Field field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetHistoryContextsRequest) SetField(field *string) {
	g.Field = field
	g.require(getHistoryContextsRequestFieldField)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetHistoryContextsRequest) SetLimit(limit *int) {
	g.Limit = limit
	g.require(getHistoryContextsRequestFieldLimit)
}

var (
	getInstanceContextsRequestFieldSlug     = big.NewInt(1 << 0)
	getInstanceContextsRequestFieldInstance = big.NewInt(1 << 1)
)

type GetInstanceContextsRequest struct {
	// The unique slug for the context.
	Slug string `json:"-" url:"-"`
	// The unique identifier for the context instance.
	Instance string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (g *GetInstanceContextsRequest) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetInstanceContextsRequest) SetSlug(slug string) {
	g.Slug = slug
	g.require(getInstanceContextsRequestFieldSlug)
}

// SetInstance sets the Instance field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetInstanceContextsRequest) SetInstance(instance string) {
	g.Instance = instance
	g.require(getInstanceContextsRequestFieldInstance)
}

var (
	getPendingContextsRequestFieldSlug     = big.NewInt(1 << 0)
	getPendingContextsRequestFieldInstance = big.NewInt(1 << 1)
)

type GetPendingContextsRequest struct {
	// The unique slug for the context.
	Slug string `json:"-" url:"-"`
	// The unique identifier for the context instance.
	Instance string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (g *GetPendingContextsRequest) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetPendingContextsRequest) SetSlug(slug string) {
	g.Slug = slug
	g.require(getPendingContextsRequestFieldSlug)
}

// SetInstance sets the Instance field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetPendingContextsRequest) SetInstance(instance string) {
	g.Instance = instance
	g.require(getPendingContextsRequestFieldInstance)
}

var (
	solveContextRuleRequestFieldSlug           = big.NewInt(1 << 0)
	solveContextRuleRequestFieldInstance       = big.NewInt(1 << 1)
	solveContextRuleRequestFieldRuleSlug       = big.NewInt(1 << 2)
	solveContextRuleRequestFieldAdditionalData = big.NewInt(1 << 3)
	solveContextRuleRequestFieldPersist        = big.NewInt(1 << 4)
)

type SolveContextRuleRequest struct {
	// The unique slug for the context.
	Slug string `json:"-" url:"-"`
	// The unique identifier for the context instance.
	Instance string `json:"-" url:"-"`
	// The unique slug for the rule.
	RuleSlug string `json:"-" url:"-"`
	// Additional data to merge with instance state for rule evaluation.
	AdditionalData map[string]interface{} `json:"additionalData,omitempty" url:"-"`
	// Whether to persist derived outputs to the instance.
	Persist *bool `json:"persist,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *SolveContextRuleRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextRuleRequest) SetSlug(slug string) {
	s.Slug = slug
	s.require(solveContextRuleRequestFieldSlug)
}

// SetInstance sets the Instance field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextRuleRequest) SetInstance(instance string) {
	s.Instance = instance
	s.require(solveContextRuleRequestFieldInstance)
}

// SetRuleSlug sets the RuleSlug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextRuleRequest) SetRuleSlug(ruleSlug string) {
	s.RuleSlug = ruleSlug
	s.require(solveContextRuleRequestFieldRuleSlug)
}

// SetAdditionalData sets the AdditionalData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextRuleRequest) SetAdditionalData(additionalData map[string]interface{}) {
	s.AdditionalData = additionalData
	s.require(solveContextRuleRequestFieldAdditionalData)
}

// SetPersist sets the Persist field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextRuleRequest) SetPersist(persist *bool) {
	s.Persist = persist
	s.require(solveContextRuleRequestFieldPersist)
}

var (
	submitContextsRequestFieldSlug     = big.NewInt(1 << 0)
	submitContextsRequestFieldInstance = big.NewInt(1 << 1)
)

type SubmitContextsRequest struct {
	// The unique slug for the context.
	Slug string `json:"-" url:"-"`
	// The unique identifier for the context instance.
	Instance string                   `json:"-" url:"-"`
	Body     SubmitContextDataRequest `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *SubmitContextsRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubmitContextsRequest) SetSlug(slug string) {
	s.Slug = slug
	s.require(submitContextsRequestFieldSlug)
}

// SetInstance sets the Instance field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubmitContextsRequest) SetInstance(instance string) {
	s.Instance = instance
	s.require(submitContextsRequestFieldInstance)
}

func (s *SubmitContextsRequest) UnmarshalJSON(data []byte) error {
	var body SubmitContextDataRequest
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	s.Body = body
	return nil
}

func (s *SubmitContextsRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.Body)
}

// Response after triggering a cascade re-evaluation of pending rules/flows.
var (
	cascadeContextResponseFieldContext  = big.NewInt(1 << 0)
	cascadeContextResponseFieldCascaded = big.NewInt(1 << 1)
)

type CascadeContextResponse struct {
	// Combined identifier in format 'contextSlug:instanceId'.
	Context *string `json:"context,omitempty" url:"context,omitempty"`
	// Results from all cascaded evaluations.
	Cascaded []*CascadeResult `json:"cascaded,omitempty" url:"cascaded,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CascadeContextResponse) GetContext() *string {
	if c == nil {
		return nil
	}
	return c.Context
}

func (c *CascadeContextResponse) GetCascaded() []*CascadeResult {
	if c == nil {
		return nil
	}
	return c.Cascaded
}

func (c *CascadeContextResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CascadeContextResponse) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetContext sets the Context field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CascadeContextResponse) SetContext(context *string) {
	c.Context = context
	c.require(cascadeContextResponseFieldContext)
}

// SetCascaded sets the Cascaded field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CascadeContextResponse) SetCascaded(cascaded []*CascadeResult) {
	c.Cascaded = cascaded
	c.require(cascadeContextResponseFieldCascaded)
}

func (c *CascadeContextResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CascadeContextResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CascadeContextResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CascadeContextResponse) MarshalJSON() ([]byte, error) {
	type embed CascadeContextResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CascadeContextResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Result of an auto-executed or cascaded rule/flow evaluation.
var (
	cascadeResultFieldContext          = big.NewInt(1 << 0)
	cascadeResultFieldRule             = big.NewInt(1 << 1)
	cascadeResultFieldFlow             = big.NewInt(1 << 2)
	cascadeResultFieldStatus           = big.NewInt(1 << 3)
	cascadeResultFieldResult           = big.NewInt(1 << 4)
	cascadeResultFieldAutoExecuted     = big.NewInt(1 << 5)
	cascadeResultFieldWrittenToContext = big.NewInt(1 << 6)
	cascadeResultFieldError            = big.NewInt(1 << 7)
)

type CascadeResult struct {
	// Combined identifier in format 'contextSlug:instanceId'.
	Context *string `json:"context,omitempty" url:"context,omitempty"`
	// The rule slug (if this was a rule evaluation).
	Rule *string `json:"rule,omitempty" url:"rule,omitempty"`
	// The flow slug (if this was a flow evaluation).
	Flow *string `json:"flow,omitempty" url:"flow,omitempty"`
	// Whether the evaluation succeeded.
	Status *CascadeResultStatus `json:"status,omitempty" url:"status,omitempty"`
	// The evaluation output.
	Result map[string]interface{} `json:"result,omitempty" url:"result,omitempty"`
	// Whether this was auto-executed (true) or from a registered pending evaluation (false).
	AutoExecuted *bool `json:"auto_executed,omitempty" url:"auto_executed,omitempty"`
	// List of field keys written back to the context (for rule evaluations).
	WrittenToContext []string `json:"written_to_context,omitempty" url:"written_to_context,omitempty"`
	// Error message if the evaluation failed.
	Error *string `json:"error,omitempty" url:"error,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CascadeResult) GetContext() *string {
	if c == nil {
		return nil
	}
	return c.Context
}

func (c *CascadeResult) GetRule() *string {
	if c == nil {
		return nil
	}
	return c.Rule
}

func (c *CascadeResult) GetFlow() *string {
	if c == nil {
		return nil
	}
	return c.Flow
}

func (c *CascadeResult) GetStatus() *CascadeResultStatus {
	if c == nil {
		return nil
	}
	return c.Status
}

func (c *CascadeResult) GetResult() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Result
}

func (c *CascadeResult) GetAutoExecuted() *bool {
	if c == nil {
		return nil
	}
	return c.AutoExecuted
}

func (c *CascadeResult) GetWrittenToContext() []string {
	if c == nil {
		return nil
	}
	return c.WrittenToContext
}

func (c *CascadeResult) GetError() *string {
	if c == nil {
		return nil
	}
	return c.Error
}

func (c *CascadeResult) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CascadeResult) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetContext sets the Context field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CascadeResult) SetContext(context *string) {
	c.Context = context
	c.require(cascadeResultFieldContext)
}

// SetRule sets the Rule field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CascadeResult) SetRule(rule *string) {
	c.Rule = rule
	c.require(cascadeResultFieldRule)
}

// SetFlow sets the Flow field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CascadeResult) SetFlow(flow *string) {
	c.Flow = flow
	c.require(cascadeResultFieldFlow)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CascadeResult) SetStatus(status *CascadeResultStatus) {
	c.Status = status
	c.require(cascadeResultFieldStatus)
}

// SetResult sets the Result field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CascadeResult) SetResult(result map[string]interface{}) {
	c.Result = result
	c.require(cascadeResultFieldResult)
}

// SetAutoExecuted sets the AutoExecuted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CascadeResult) SetAutoExecuted(autoExecuted *bool) {
	c.AutoExecuted = autoExecuted
	c.require(cascadeResultFieldAutoExecuted)
}

// SetWrittenToContext sets the WrittenToContext field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CascadeResult) SetWrittenToContext(writtenToContext []string) {
	c.WrittenToContext = writtenToContext
	c.require(cascadeResultFieldWrittenToContext)
}

// SetError sets the Error field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CascadeResult) SetError(error_ *string) {
	c.Error = error_
	c.require(cascadeResultFieldError)
}

func (c *CascadeResult) UnmarshalJSON(data []byte) error {
	type unmarshaler CascadeResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CascadeResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CascadeResult) MarshalJSON() ([]byte, error) {
	type embed CascadeResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CascadeResult) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Whether the evaluation succeeded.
type CascadeResultStatus string

const (
	CascadeResultStatusSolved CascadeResultStatus = "solved"
	CascadeResultStatusError  CascadeResultStatus = "error"
)

func NewCascadeResultStatusFromString(s string) (CascadeResultStatus, error) {
	switch s {
	case "solved":
		return CascadeResultStatusSolved, nil
	case "error":
		return CascadeResultStatusError, nil
	}
	var t CascadeResultStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CascadeResultStatus) Ptr() *CascadeResultStatus {
	return &c
}

// Historical values for context instance fields.
var (
	contextInstanceHistoryFieldContext = big.NewInt(1 << 0)
	contextInstanceHistoryFieldHistory = big.NewInt(1 << 1)
)

type ContextInstanceHistory struct {
	// Combined identifier in format 'contextSlug:instanceId'.
	Context *string `json:"context,omitempty" url:"context,omitempty"`
	// Map of field keys to arrays of historical values, newest first.
	History map[string][]*ContextInstanceHistoryEntry `json:"history,omitempty" url:"history,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextInstanceHistory) GetContext() *string {
	if c == nil {
		return nil
	}
	return c.Context
}

func (c *ContextInstanceHistory) GetHistory() map[string][]*ContextInstanceHistoryEntry {
	if c == nil {
		return nil
	}
	return c.History
}

func (c *ContextInstanceHistory) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextInstanceHistory) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetContext sets the Context field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstanceHistory) SetContext(context *string) {
	c.Context = context
	c.require(contextInstanceHistoryFieldContext)
}

// SetHistory sets the History field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstanceHistory) SetHistory(history map[string][]*ContextInstanceHistoryEntry) {
	c.History = history
	c.require(contextInstanceHistoryFieldHistory)
}

func (c *ContextInstanceHistory) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextInstanceHistory
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextInstanceHistory(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextInstanceHistory) MarshalJSON() ([]byte, error) {
	type embed ContextInstanceHistory
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextInstanceHistory) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A single history entry for a field value.
var (
	contextInstanceHistoryEntryFieldTimestamp = big.NewInt(1 << 0)
	contextInstanceHistoryEntryFieldValue     = big.NewInt(1 << 1)
)

type ContextInstanceHistoryEntry struct {
	// When this value was recorded.
	Timestamp *time.Time `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// The field value at this point in time.
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextInstanceHistoryEntry) GetTimestamp() *time.Time {
	if c == nil {
		return nil
	}
	return c.Timestamp
}

func (c *ContextInstanceHistoryEntry) GetValue() interface{} {
	if c == nil {
		return nil
	}
	return c.Value
}

func (c *ContextInstanceHistoryEntry) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextInstanceHistoryEntry) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstanceHistoryEntry) SetTimestamp(timestamp *time.Time) {
	c.Timestamp = timestamp
	c.require(contextInstanceHistoryEntryFieldTimestamp)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstanceHistoryEntry) SetValue(value interface{}) {
	c.Value = value
	c.require(contextInstanceHistoryEntryFieldValue)
}

func (c *ContextInstanceHistoryEntry) UnmarshalJSON(data []byte) error {
	type embed ContextInstanceHistoryEntry
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ContextInstanceHistoryEntry(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextInstanceHistoryEntry) MarshalJSON() ([]byte, error) {
	type embed ContextInstanceHistoryEntry
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewOptionalDateTime(c.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextInstanceHistoryEntry) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A pending rule or flow evaluation awaiting data.
var (
	contextInstancePendingEvaluationFieldType      = big.NewInt(1 << 0)
	contextInstancePendingEvaluationFieldRule      = big.NewInt(1 << 1)
	contextInstancePendingEvaluationFieldRuleID    = big.NewInt(1 << 2)
	contextInstancePendingEvaluationFieldFlow      = big.NewInt(1 << 3)
	contextInstancePendingEvaluationFieldFlowID    = big.NewInt(1 << 4)
	contextInstancePendingEvaluationFieldWaitingOn = big.NewInt(1 << 5)
	contextInstancePendingEvaluationFieldCreatedAt = big.NewInt(1 << 6)
	contextInstancePendingEvaluationFieldExpiresAt = big.NewInt(1 << 7)
)

type ContextInstancePendingEvaluation struct {
	// Whether this is a rule or flow evaluation.
	Type *ContextInstancePendingEvaluationType `json:"type,omitempty" url:"type,omitempty"`
	// The rule slug (if type is 'rule').
	Rule *string `json:"rule,omitempty" url:"rule,omitempty"`
	// The rule ID (if type is 'rule').
	RuleID *string `json:"rule_id,omitempty" url:"rule_id,omitempty"`
	// The flow slug (if type is 'flow').
	Flow *string `json:"flow,omitempty" url:"flow,omitempty"`
	// The flow ID (if type is 'flow').
	FlowID *string `json:"flow_id,omitempty" url:"flow_id,omitempty"`
	// List of field keys this evaluation is waiting for.
	WaitingOn []string `json:"waiting_on,omitempty" url:"waiting_on,omitempty"`
	// When this pending evaluation was registered.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// When this pending evaluation will expire.
	ExpiresAt *time.Time `json:"expires_at,omitempty" url:"expires_at,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextInstancePendingEvaluation) GetType() *ContextInstancePendingEvaluationType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *ContextInstancePendingEvaluation) GetRule() *string {
	if c == nil {
		return nil
	}
	return c.Rule
}

func (c *ContextInstancePendingEvaluation) GetRuleID() *string {
	if c == nil {
		return nil
	}
	return c.RuleID
}

func (c *ContextInstancePendingEvaluation) GetFlow() *string {
	if c == nil {
		return nil
	}
	return c.Flow
}

func (c *ContextInstancePendingEvaluation) GetFlowID() *string {
	if c == nil {
		return nil
	}
	return c.FlowID
}

func (c *ContextInstancePendingEvaluation) GetWaitingOn() []string {
	if c == nil {
		return nil
	}
	return c.WaitingOn
}

func (c *ContextInstancePendingEvaluation) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *ContextInstancePendingEvaluation) GetExpiresAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.ExpiresAt
}

func (c *ContextInstancePendingEvaluation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextInstancePendingEvaluation) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstancePendingEvaluation) SetType(type_ *ContextInstancePendingEvaluationType) {
	c.Type = type_
	c.require(contextInstancePendingEvaluationFieldType)
}

// SetRule sets the Rule field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstancePendingEvaluation) SetRule(rule *string) {
	c.Rule = rule
	c.require(contextInstancePendingEvaluationFieldRule)
}

// SetRuleID sets the RuleID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstancePendingEvaluation) SetRuleID(ruleID *string) {
	c.RuleID = ruleID
	c.require(contextInstancePendingEvaluationFieldRuleID)
}

// SetFlow sets the Flow field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstancePendingEvaluation) SetFlow(flow *string) {
	c.Flow = flow
	c.require(contextInstancePendingEvaluationFieldFlow)
}

// SetFlowID sets the FlowID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstancePendingEvaluation) SetFlowID(flowID *string) {
	c.FlowID = flowID
	c.require(contextInstancePendingEvaluationFieldFlowID)
}

// SetWaitingOn sets the WaitingOn field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstancePendingEvaluation) SetWaitingOn(waitingOn []string) {
	c.WaitingOn = waitingOn
	c.require(contextInstancePendingEvaluationFieldWaitingOn)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstancePendingEvaluation) SetCreatedAt(createdAt *time.Time) {
	c.CreatedAt = createdAt
	c.require(contextInstancePendingEvaluationFieldCreatedAt)
}

// SetExpiresAt sets the ExpiresAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstancePendingEvaluation) SetExpiresAt(expiresAt *time.Time) {
	c.ExpiresAt = expiresAt
	c.require(contextInstancePendingEvaluationFieldExpiresAt)
}

func (c *ContextInstancePendingEvaluation) UnmarshalJSON(data []byte) error {
	type embed ContextInstancePendingEvaluation
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		ExpiresAt *internal.DateTime `json:"expires_at,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ContextInstancePendingEvaluation(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.ExpiresAt = unmarshaler.ExpiresAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextInstancePendingEvaluation) MarshalJSON() ([]byte, error) {
	type embed ContextInstancePendingEvaluation
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		ExpiresAt *internal.DateTime `json:"expires_at,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewOptionalDateTime(c.CreatedAt),
		ExpiresAt: internal.NewOptionalDateTime(c.ExpiresAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextInstancePendingEvaluation) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Whether this is a rule or flow evaluation.
type ContextInstancePendingEvaluationType string

const (
	ContextInstancePendingEvaluationTypeRule ContextInstancePendingEvaluationType = "rule"
	ContextInstancePendingEvaluationTypeFlow ContextInstancePendingEvaluationType = "flow"
)

func NewContextInstancePendingEvaluationTypeFromString(s string) (ContextInstancePendingEvaluationType, error) {
	switch s {
	case "rule":
		return ContextInstancePendingEvaluationTypeRule, nil
	case "flow":
		return ContextInstancePendingEvaluationTypeFlow, nil
	}
	var t ContextInstancePendingEvaluationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ContextInstancePendingEvaluationType) Ptr() *ContextInstancePendingEvaluationType {
	return &c
}

// List of pending evaluations for a context instance.
var (
	contextInstancePendingResponseFieldPending = big.NewInt(1 << 0)
)

type ContextInstancePendingResponse struct {
	// Pending rule and flow evaluations.
	Pending []*ContextInstancePendingEvaluation `json:"pending,omitempty" url:"pending,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextInstancePendingResponse) GetPending() []*ContextInstancePendingEvaluation {
	if c == nil {
		return nil
	}
	return c.Pending
}

func (c *ContextInstancePendingResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextInstancePendingResponse) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetPending sets the Pending field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstancePendingResponse) SetPending(pending []*ContextInstancePendingEvaluation) {
	c.Pending = pending
	c.require(contextInstancePendingResponseFieldPending)
}

func (c *ContextInstancePendingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextInstancePendingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextInstancePendingResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextInstancePendingResponse) MarshalJSON() ([]byte, error) {
	type embed ContextInstancePendingResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextInstancePendingResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The current state of a context instance.
var (
	contextInstanceStateFieldContext   = big.NewInt(1 << 0)
	contextInstanceStateFieldState     = big.NewInt(1 << 1)
	contextInstanceStateFieldDerived   = big.NewInt(1 << 2)
	contextInstanceStateFieldStatus    = big.NewInt(1 << 3)
	contextInstanceStateFieldHave      = big.NewInt(1 << 4)
	contextInstanceStateFieldNeed      = big.NewInt(1 << 5)
	contextInstanceStateFieldCreatedAt = big.NewInt(1 << 6)
	contextInstanceStateFieldUpdatedAt = big.NewInt(1 << 7)
	contextInstanceStateFieldExpiresAt = big.NewInt(1 << 8)
)

type ContextInstanceState struct {
	// Combined identifier in format 'contextSlug:instanceId'.
	Context *string `json:"context,omitempty" url:"context,omitempty"`
	// The current base field values for this instance.
	State map[string]interface{} `json:"state,omitempty" url:"state,omitempty"`
	// Computed/derived field values from bound rules.
	Derived map[string]interface{} `json:"derived,omitempty" url:"derived,omitempty"`
	// Whether all required fields are present ('complete') or some are missing ('pending').
	Status *ContextInstanceStateStatus `json:"status,omitempty" url:"status,omitempty"`
	// List of field keys that are currently populated.
	Have []string `json:"have,omitempty" url:"have,omitempty"`
	// List of required field keys that are missing (empty when status is 'complete').
	Need []string `json:"need,omitempty" url:"need,omitempty"`
	// When the instance was first created.
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// When the instance was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// When the instance will expire based on context TTL.
	ExpiresAt *time.Time `json:"expires_at,omitempty" url:"expires_at,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextInstanceState) GetContext() *string {
	if c == nil {
		return nil
	}
	return c.Context
}

func (c *ContextInstanceState) GetState() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.State
}

func (c *ContextInstanceState) GetDerived() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Derived
}

func (c *ContextInstanceState) GetStatus() *ContextInstanceStateStatus {
	if c == nil {
		return nil
	}
	return c.Status
}

func (c *ContextInstanceState) GetHave() []string {
	if c == nil {
		return nil
	}
	return c.Have
}

func (c *ContextInstanceState) GetNeed() []string {
	if c == nil {
		return nil
	}
	return c.Need
}

func (c *ContextInstanceState) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *ContextInstanceState) GetUpdatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *ContextInstanceState) GetExpiresAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.ExpiresAt
}

func (c *ContextInstanceState) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextInstanceState) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetContext sets the Context field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstanceState) SetContext(context *string) {
	c.Context = context
	c.require(contextInstanceStateFieldContext)
}

// SetState sets the State field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstanceState) SetState(state map[string]interface{}) {
	c.State = state
	c.require(contextInstanceStateFieldState)
}

// SetDerived sets the Derived field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstanceState) SetDerived(derived map[string]interface{}) {
	c.Derived = derived
	c.require(contextInstanceStateFieldDerived)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstanceState) SetStatus(status *ContextInstanceStateStatus) {
	c.Status = status
	c.require(contextInstanceStateFieldStatus)
}

// SetHave sets the Have field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstanceState) SetHave(have []string) {
	c.Have = have
	c.require(contextInstanceStateFieldHave)
}

// SetNeed sets the Need field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstanceState) SetNeed(need []string) {
	c.Need = need
	c.require(contextInstanceStateFieldNeed)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstanceState) SetCreatedAt(createdAt *time.Time) {
	c.CreatedAt = createdAt
	c.require(contextInstanceStateFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstanceState) SetUpdatedAt(updatedAt *time.Time) {
	c.UpdatedAt = updatedAt
	c.require(contextInstanceStateFieldUpdatedAt)
}

// SetExpiresAt sets the ExpiresAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInstanceState) SetExpiresAt(expiresAt *time.Time) {
	c.ExpiresAt = expiresAt
	c.require(contextInstanceStateFieldExpiresAt)
}

func (c *ContextInstanceState) UnmarshalJSON(data []byte) error {
	type embed ContextInstanceState
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
		ExpiresAt *internal.DateTime `json:"expires_at,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ContextInstanceState(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	c.ExpiresAt = unmarshaler.ExpiresAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextInstanceState) MarshalJSON() ([]byte, error) {
	type embed ContextInstanceState
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
		ExpiresAt *internal.DateTime `json:"expires_at,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewOptionalDateTime(c.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(c.UpdatedAt),
		ExpiresAt: internal.NewOptionalDateTime(c.ExpiresAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextInstanceState) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Whether all required fields are present ('complete') or some are missing ('pending').
type ContextInstanceStateStatus string

const (
	ContextInstanceStateStatusComplete ContextInstanceStateStatus = "complete"
	ContextInstanceStateStatusPending  ContextInstanceStateStatus = "pending"
)

func NewContextInstanceStateStatusFromString(s string) (ContextInstanceStateStatus, error) {
	switch s {
	case "complete":
		return ContextInstanceStateStatusComplete, nil
	case "pending":
		return ContextInstanceStateStatusPending, nil
	}
	var t ContextInstanceStateStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ContextInstanceStateStatus) Ptr() *ContextInstanceStateStatus {
	return &c
}

// Response after deleting a context instance.
var (
	deleteContextInstanceResponseFieldMessage                     = big.NewInt(1 << 0)
	deleteContextInstanceResponseFieldPendingEvaluationsCancelled = big.NewInt(1 << 1)
)

type DeleteContextInstanceResponse struct {
	// Success message.
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// Number of pending evaluations that were cancelled when the instance was deleted.
	PendingEvaluationsCancelled *int `json:"pending_evaluations_cancelled,omitempty" url:"pending_evaluations_cancelled,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteContextInstanceResponse) GetMessage() *string {
	if d == nil {
		return nil
	}
	return d.Message
}

func (d *DeleteContextInstanceResponse) GetPendingEvaluationsCancelled() *int {
	if d == nil {
		return nil
	}
	return d.PendingEvaluationsCancelled
}

func (d *DeleteContextInstanceResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteContextInstanceResponse) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteContextInstanceResponse) SetMessage(message *string) {
	d.Message = message
	d.require(deleteContextInstanceResponseFieldMessage)
}

// SetPendingEvaluationsCancelled sets the PendingEvaluationsCancelled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteContextInstanceResponse) SetPendingEvaluationsCancelled(pendingEvaluationsCancelled *int) {
	d.PendingEvaluationsCancelled = pendingEvaluationsCancelled
	d.require(deleteContextInstanceResponseFieldPendingEvaluationsCancelled)
}

func (d *DeleteContextInstanceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteContextInstanceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteContextInstanceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteContextInstanceResponse) MarshalJSON() ([]byte, error) {
	type embed DeleteContextInstanceResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DeleteContextInstanceResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Response after executing a flow against a context instance.
var (
	solveContextFlowResponseFieldStatus  = big.NewInt(1 << 0)
	solveContextFlowResponseFieldContext = big.NewInt(1 << 1)
	solveContextFlowResponseFieldFlow    = big.NewInt(1 << 2)
	solveContextFlowResponseFieldResult  = big.NewInt(1 << 3)
	solveContextFlowResponseFieldUsage   = big.NewInt(1 << 4)
)

type SolveContextFlowResponse struct {
	// Whether the flow executed successfully.
	Status *SolveContextFlowResponseStatus `json:"status,omitempty" url:"status,omitempty"`
	// Combined identifier in format 'contextSlug:instanceId'.
	Context *string `json:"context,omitempty" url:"context,omitempty"`
	// The slug of the flow that was executed.
	Flow *string `json:"flow,omitempty" url:"flow,omitempty"`
	// The flow execution output.
	Result map[string]interface{} `json:"result,omitempty" url:"result,omitempty"`
	// Resource usage information for the flow execution.
	Usage map[string]interface{} `json:"usage,omitempty" url:"usage,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SolveContextFlowResponse) GetStatus() *SolveContextFlowResponseStatus {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *SolveContextFlowResponse) GetContext() *string {
	if s == nil {
		return nil
	}
	return s.Context
}

func (s *SolveContextFlowResponse) GetFlow() *string {
	if s == nil {
		return nil
	}
	return s.Flow
}

func (s *SolveContextFlowResponse) GetResult() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.Result
}

func (s *SolveContextFlowResponse) GetUsage() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.Usage
}

func (s *SolveContextFlowResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SolveContextFlowResponse) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextFlowResponse) SetStatus(status *SolveContextFlowResponseStatus) {
	s.Status = status
	s.require(solveContextFlowResponseFieldStatus)
}

// SetContext sets the Context field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextFlowResponse) SetContext(context *string) {
	s.Context = context
	s.require(solveContextFlowResponseFieldContext)
}

// SetFlow sets the Flow field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextFlowResponse) SetFlow(flow *string) {
	s.Flow = flow
	s.require(solveContextFlowResponseFieldFlow)
}

// SetResult sets the Result field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextFlowResponse) SetResult(result map[string]interface{}) {
	s.Result = result
	s.require(solveContextFlowResponseFieldResult)
}

// SetUsage sets the Usage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextFlowResponse) SetUsage(usage map[string]interface{}) {
	s.Usage = usage
	s.require(solveContextFlowResponseFieldUsage)
}

func (s *SolveContextFlowResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SolveContextFlowResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SolveContextFlowResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SolveContextFlowResponse) MarshalJSON() ([]byte, error) {
	type embed SolveContextFlowResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SolveContextFlowResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Whether the flow executed successfully.
type SolveContextFlowResponseStatus string

const (
	SolveContextFlowResponseStatusSolved SolveContextFlowResponseStatus = "solved"
	SolveContextFlowResponseStatusError  SolveContextFlowResponseStatus = "error"
)

func NewSolveContextFlowResponseStatusFromString(s string) (SolveContextFlowResponseStatus, error) {
	switch s {
	case "solved":
		return SolveContextFlowResponseStatusSolved, nil
	case "error":
		return SolveContextFlowResponseStatusError, nil
	}
	var t SolveContextFlowResponseStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SolveContextFlowResponseStatus) Ptr() *SolveContextFlowResponseStatus {
	return &s
}

// Response after solving a rule against a context instance.
var (
	solveContextRuleResponseFieldStatus           = big.NewInt(1 << 0)
	solveContextRuleResponseFieldContext          = big.NewInt(1 << 1)
	solveContextRuleResponseFieldRule             = big.NewInt(1 << 2)
	solveContextRuleResponseFieldResult           = big.NewInt(1 << 3)
	solveContextRuleResponseFieldWrittenToContext = big.NewInt(1 << 4)
	solveContextRuleResponseFieldCascaded         = big.NewInt(1 << 5)
)

type SolveContextRuleResponse struct {
	// Whether the rule executed successfully.
	Status *SolveContextRuleResponseStatus `json:"status,omitempty" url:"status,omitempty"`
	// Combined identifier in format 'contextSlug:instanceId'.
	Context *string `json:"context,omitempty" url:"context,omitempty"`
	// The slug of the rule that was executed.
	Rule *string `json:"rule,omitempty" url:"rule,omitempty"`
	// The rule evaluation result (output values).
	Result map[string]interface{} `json:"result,omitempty" url:"result,omitempty"`
	// List of field keys that were written back to the context instance.
	WrittenToContext []string `json:"written_to_context,omitempty" url:"written_to_context,omitempty"`
	// Results from any cascaded evaluations triggered by the rule outputs.
	Cascaded []*CascadeResult `json:"cascaded,omitempty" url:"cascaded,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SolveContextRuleResponse) GetStatus() *SolveContextRuleResponseStatus {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *SolveContextRuleResponse) GetContext() *string {
	if s == nil {
		return nil
	}
	return s.Context
}

func (s *SolveContextRuleResponse) GetRule() *string {
	if s == nil {
		return nil
	}
	return s.Rule
}

func (s *SolveContextRuleResponse) GetResult() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.Result
}

func (s *SolveContextRuleResponse) GetWrittenToContext() []string {
	if s == nil {
		return nil
	}
	return s.WrittenToContext
}

func (s *SolveContextRuleResponse) GetCascaded() []*CascadeResult {
	if s == nil {
		return nil
	}
	return s.Cascaded
}

func (s *SolveContextRuleResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SolveContextRuleResponse) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextRuleResponse) SetStatus(status *SolveContextRuleResponseStatus) {
	s.Status = status
	s.require(solveContextRuleResponseFieldStatus)
}

// SetContext sets the Context field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextRuleResponse) SetContext(context *string) {
	s.Context = context
	s.require(solveContextRuleResponseFieldContext)
}

// SetRule sets the Rule field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextRuleResponse) SetRule(rule *string) {
	s.Rule = rule
	s.require(solveContextRuleResponseFieldRule)
}

// SetResult sets the Result field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextRuleResponse) SetResult(result map[string]interface{}) {
	s.Result = result
	s.require(solveContextRuleResponseFieldResult)
}

// SetWrittenToContext sets the WrittenToContext field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextRuleResponse) SetWrittenToContext(writtenToContext []string) {
	s.WrittenToContext = writtenToContext
	s.require(solveContextRuleResponseFieldWrittenToContext)
}

// SetCascaded sets the Cascaded field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SolveContextRuleResponse) SetCascaded(cascaded []*CascadeResult) {
	s.Cascaded = cascaded
	s.require(solveContextRuleResponseFieldCascaded)
}

func (s *SolveContextRuleResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SolveContextRuleResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SolveContextRuleResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SolveContextRuleResponse) MarshalJSON() ([]byte, error) {
	type embed SolveContextRuleResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SolveContextRuleResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Whether the rule executed successfully.
type SolveContextRuleResponseStatus string

const (
	SolveContextRuleResponseStatusSolved SolveContextRuleResponseStatus = "solved"
	SolveContextRuleResponseStatusError  SolveContextRuleResponseStatus = "error"
)

func NewSolveContextRuleResponseStatusFromString(s string) (SolveContextRuleResponseStatus, error) {
	switch s {
	case "solved":
		return SolveContextRuleResponseStatusSolved, nil
	case "error":
		return SolveContextRuleResponseStatusError, nil
	}
	var t SolveContextRuleResponseStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SolveContextRuleResponseStatus) Ptr() *SolveContextRuleResponseStatus {
	return &s
}

// Data to submit to a context instance. Keys should match the context schema fields.
type SubmitContextDataRequest = map[string]interface{}

// Response after submitting data, including any auto-executed evaluations.
var (
	submitContextDataResponseFieldContext   = big.NewInt(1 << 0)
	submitContextDataResponseFieldState     = big.NewInt(1 << 1)
	submitContextDataResponseFieldStatus    = big.NewInt(1 << 2)
	submitContextDataResponseFieldHave      = big.NewInt(1 << 3)
	submitContextDataResponseFieldNeed      = big.NewInt(1 << 4)
	submitContextDataResponseFieldIsNew     = big.NewInt(1 << 5)
	submitContextDataResponseFieldExpiresAt = big.NewInt(1 << 6)
	submitContextDataResponseFieldCascaded  = big.NewInt(1 << 7)
)

type SubmitContextDataResponse struct {
	// Combined identifier in format 'contextSlug:instanceId'.
	Context *string `json:"context,omitempty" url:"context,omitempty"`
	// The merged state after submitting data and any auto-executed rules/flows.
	State map[string]interface{} `json:"state,omitempty" url:"state,omitempty"`
	// Whether all required fields are present ('complete') or some are missing ('pending').
	Status *SubmitContextDataResponseStatus `json:"status,omitempty" url:"status,omitempty"`
	// List of field keys that are currently populated.
	Have []string `json:"have,omitempty" url:"have,omitempty"`
	// List of required field keys that are still missing.
	Need []string `json:"need,omitempty" url:"need,omitempty"`
	// Whether this submission created a new instance (true) or updated an existing one (false).
	IsNew *bool `json:"is_new,omitempty" url:"is_new,omitempty"`
	// When the instance will expire based on context TTL.
	ExpiresAt *time.Time `json:"expires_at,omitempty" url:"expires_at,omitempty"`
	// Results from auto-executed rules/flows and pending evaluation cascades.
	Cascaded []*CascadeResult `json:"cascaded,omitempty" url:"cascaded,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubmitContextDataResponse) GetContext() *string {
	if s == nil {
		return nil
	}
	return s.Context
}

func (s *SubmitContextDataResponse) GetState() map[string]interface{} {
	if s == nil {
		return nil
	}
	return s.State
}

func (s *SubmitContextDataResponse) GetStatus() *SubmitContextDataResponseStatus {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *SubmitContextDataResponse) GetHave() []string {
	if s == nil {
		return nil
	}
	return s.Have
}

func (s *SubmitContextDataResponse) GetNeed() []string {
	if s == nil {
		return nil
	}
	return s.Need
}

func (s *SubmitContextDataResponse) GetIsNew() *bool {
	if s == nil {
		return nil
	}
	return s.IsNew
}

func (s *SubmitContextDataResponse) GetExpiresAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.ExpiresAt
}

func (s *SubmitContextDataResponse) GetCascaded() []*CascadeResult {
	if s == nil {
		return nil
	}
	return s.Cascaded
}

func (s *SubmitContextDataResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubmitContextDataResponse) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetContext sets the Context field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubmitContextDataResponse) SetContext(context *string) {
	s.Context = context
	s.require(submitContextDataResponseFieldContext)
}

// SetState sets the State field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubmitContextDataResponse) SetState(state map[string]interface{}) {
	s.State = state
	s.require(submitContextDataResponseFieldState)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubmitContextDataResponse) SetStatus(status *SubmitContextDataResponseStatus) {
	s.Status = status
	s.require(submitContextDataResponseFieldStatus)
}

// SetHave sets the Have field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubmitContextDataResponse) SetHave(have []string) {
	s.Have = have
	s.require(submitContextDataResponseFieldHave)
}

// SetNeed sets the Need field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubmitContextDataResponse) SetNeed(need []string) {
	s.Need = need
	s.require(submitContextDataResponseFieldNeed)
}

// SetIsNew sets the IsNew field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubmitContextDataResponse) SetIsNew(isNew *bool) {
	s.IsNew = isNew
	s.require(submitContextDataResponseFieldIsNew)
}

// SetExpiresAt sets the ExpiresAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubmitContextDataResponse) SetExpiresAt(expiresAt *time.Time) {
	s.ExpiresAt = expiresAt
	s.require(submitContextDataResponseFieldExpiresAt)
}

// SetCascaded sets the Cascaded field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubmitContextDataResponse) SetCascaded(cascaded []*CascadeResult) {
	s.Cascaded = cascaded
	s.require(submitContextDataResponseFieldCascaded)
}

func (s *SubmitContextDataResponse) UnmarshalJSON(data []byte) error {
	type embed SubmitContextDataResponse
	var unmarshaler = struct {
		embed
		ExpiresAt *internal.DateTime `json:"expires_at,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SubmitContextDataResponse(unmarshaler.embed)
	s.ExpiresAt = unmarshaler.ExpiresAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubmitContextDataResponse) MarshalJSON() ([]byte, error) {
	type embed SubmitContextDataResponse
	var marshaler = struct {
		embed
		ExpiresAt *internal.DateTime `json:"expires_at,omitempty"`
	}{
		embed:     embed(*s),
		ExpiresAt: internal.NewOptionalDateTime(s.ExpiresAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubmitContextDataResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Whether all required fields are present ('complete') or some are missing ('pending').
type SubmitContextDataResponseStatus string

const (
	SubmitContextDataResponseStatusComplete SubmitContextDataResponseStatus = "complete"
	SubmitContextDataResponseStatusPending  SubmitContextDataResponseStatus = "pending"
)

func NewSubmitContextDataResponseStatusFromString(s string) (SubmitContextDataResponseStatus, error) {
	switch s {
	case "complete":
		return SubmitContextDataResponseStatusComplete, nil
	case "pending":
		return SubmitContextDataResponseStatusPending, nil
	}
	var t SubmitContextDataResponseStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubmitContextDataResponseStatus) Ptr() *SubmitContextDataResponseStatus {
	return &s
}
