// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"
	internal "sdk/internal"
	time "time"
)

var (
	queryDecisionsRequestFieldSearch   = big.NewInt(1 << 0)
	queryDecisionsRequestFieldRules    = big.NewInt(1 << 1)
	queryDecisionsRequestFieldStatuses = big.NewInt(1 << 2)
	queryDecisionsRequestFieldStart    = big.NewInt(1 << 3)
	queryDecisionsRequestFieldEnd      = big.NewInt(1 << 4)
	queryDecisionsRequestFieldCursor   = big.NewInt(1 << 5)
	queryDecisionsRequestFieldLimit    = big.NewInt(1 << 6)
	queryDecisionsRequestFieldCount    = big.NewInt(1 << 7)
	queryDecisionsRequestFieldSlug     = big.NewInt(1 << 8)
)

type QueryDecisionsRequest struct {
	// Decision data query language expression to filter logs by request/response data. Supports field comparisons (`field=value`, `field>10`), contains (`field:text`), not-contains (`field!:text`), boolean operators (`AND`, `OR`), and parentheses.
	Search *string `json:"-" url:"search,omitempty"`
	// Comma-separated list of rule names to filter logs by.
	Rules *string `json:"-" url:"rules,omitempty"`
	// Comma-separated list of HTTP status codes to filter logs by.
	Statuses *string `json:"-" url:"statuses,omitempty"`
	// Start date for the query range (ISO8601 format).
	Start *time.Time `json:"-" url:"start,omitempty"`
	// End date for the query range (ISO8601 format).
	End *time.Time `json:"-" url:"end,omitempty"`
	// Cursor for pagination (returned from previous query).
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Number of results to return per page (default: 100).
	Limit *int `json:"-" url:"limit,omitempty"`
	// If set to 'true', returns only the count of matching logs instead of the log data.
	Count *QueryDecisionsRequestCount `json:"-" url:"count,omitempty"`
	// (Deprecated) Legacy parameter for filtering by rule slug. Use 'rules' parameter instead.
	Slug *string `json:"-" url:"slug,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (q *QueryDecisionsRequest) require(field *big.Int) {
	if q.explicitFields == nil {
		q.explicitFields = big.NewInt(0)
	}
	q.explicitFields.Or(q.explicitFields, field)
}

// SetSearch sets the Search field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryDecisionsRequest) SetSearch(search *string) {
	q.Search = search
	q.require(queryDecisionsRequestFieldSearch)
}

// SetRules sets the Rules field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryDecisionsRequest) SetRules(rules *string) {
	q.Rules = rules
	q.require(queryDecisionsRequestFieldRules)
}

// SetStatuses sets the Statuses field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryDecisionsRequest) SetStatuses(statuses *string) {
	q.Statuses = statuses
	q.require(queryDecisionsRequestFieldStatuses)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryDecisionsRequest) SetStart(start *time.Time) {
	q.Start = start
	q.require(queryDecisionsRequestFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryDecisionsRequest) SetEnd(end *time.Time) {
	q.End = end
	q.require(queryDecisionsRequestFieldEnd)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryDecisionsRequest) SetCursor(cursor *string) {
	q.Cursor = cursor
	q.require(queryDecisionsRequestFieldCursor)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryDecisionsRequest) SetLimit(limit *int) {
	q.Limit = limit
	q.require(queryDecisionsRequestFieldLimit)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryDecisionsRequest) SetCount(count *QueryDecisionsRequestCount) {
	q.Count = count
	q.require(queryDecisionsRequestFieldCount)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (q *QueryDecisionsRequest) SetSlug(slug *string) {
	q.Slug = slug
	q.require(queryDecisionsRequestFieldSlug)
}

// Rule/flow execution log entry with request, response, and decision details.
var (
	decisionLogFieldTimestamp   = big.NewInt(1 << 0)
	decisionLogFieldName        = big.NewInt(1 << 1)
	decisionLogFieldEndpoint    = big.NewInt(1 << 2)
	decisionLogFieldStatus      = big.NewInt(1 << 3)
	decisionLogFieldRequest     = big.NewInt(1 << 4)
	decisionLogFieldResponse    = big.NewInt(1 << 5)
	decisionLogFieldDecision    = big.NewInt(1 << 6)
	decisionLogFieldError       = big.NewInt(1 << 7)
	decisionLogFieldAbbreviated = big.NewInt(1 << 8)
)

type DecisionLog struct {
	// When the rule/flow was executed.
	Timestamp *time.Time `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	// Name of the rule or flow that was executed.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// API endpoint that was called.
	Endpoint *string `json:"endpoint,omitempty" url:"endpoint,omitempty"`
	// HTTP status code of the response.
	Status *int `json:"status,omitempty" url:"status,omitempty"`
	// The request payload sent to the rule/flow.
	Request map[string]interface{} `json:"request,omitempty" url:"request,omitempty"`
	// The response payload returned by the rule/flow.
	Response map[string]interface{} `json:"response,omitempty" url:"response,omitempty"`
	// Decision details including matched conditions, rows, and evaluation metadata.
	Decision map[string]interface{} `json:"decision,omitempty" url:"decision,omitempty"`
	// Error message if the execution failed.
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// Whether the request/response data was truncated due to size limits.
	Abbreviated *bool `json:"abbreviated,omitempty" url:"abbreviated,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DecisionLog) GetTimestamp() *time.Time {
	if d == nil {
		return nil
	}
	return d.Timestamp
}

func (d *DecisionLog) GetName() *string {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DecisionLog) GetEndpoint() *string {
	if d == nil {
		return nil
	}
	return d.Endpoint
}

func (d *DecisionLog) GetStatus() *int {
	if d == nil {
		return nil
	}
	return d.Status
}

func (d *DecisionLog) GetRequest() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.Request
}

func (d *DecisionLog) GetResponse() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.Response
}

func (d *DecisionLog) GetDecision() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.Decision
}

func (d *DecisionLog) GetError() *string {
	if d == nil {
		return nil
	}
	return d.Error
}

func (d *DecisionLog) GetAbbreviated() *bool {
	if d == nil {
		return nil
	}
	return d.Abbreviated
}

func (d *DecisionLog) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DecisionLog) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DecisionLog) SetTimestamp(timestamp *time.Time) {
	d.Timestamp = timestamp
	d.require(decisionLogFieldTimestamp)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DecisionLog) SetName(name *string) {
	d.Name = name
	d.require(decisionLogFieldName)
}

// SetEndpoint sets the Endpoint field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DecisionLog) SetEndpoint(endpoint *string) {
	d.Endpoint = endpoint
	d.require(decisionLogFieldEndpoint)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DecisionLog) SetStatus(status *int) {
	d.Status = status
	d.require(decisionLogFieldStatus)
}

// SetRequest sets the Request field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DecisionLog) SetRequest(request map[string]interface{}) {
	d.Request = request
	d.require(decisionLogFieldRequest)
}

// SetResponse sets the Response field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DecisionLog) SetResponse(response map[string]interface{}) {
	d.Response = response
	d.require(decisionLogFieldResponse)
}

// SetDecision sets the Decision field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DecisionLog) SetDecision(decision map[string]interface{}) {
	d.Decision = decision
	d.require(decisionLogFieldDecision)
}

// SetError sets the Error field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DecisionLog) SetError(error_ *string) {
	d.Error = error_
	d.require(decisionLogFieldError)
}

// SetAbbreviated sets the Abbreviated field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DecisionLog) SetAbbreviated(abbreviated *bool) {
	d.Abbreviated = abbreviated
	d.require(decisionLogFieldAbbreviated)
}

func (d *DecisionLog) UnmarshalJSON(data []byte) error {
	type embed DecisionLog
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DecisionLog(unmarshaler.embed)
	d.Timestamp = unmarshaler.Timestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DecisionLog) MarshalJSON() ([]byte, error) {
	type embed DecisionLog
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*d),
		Timestamp: internal.NewOptionalDateTime(d.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DecisionLog) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Response containing decision logs or a count.
var (
	decisionLogResponseFieldData   = big.NewInt(1 << 0)
	decisionLogResponseFieldCursor = big.NewInt(1 << 1)
	decisionLogResponseFieldCount  = big.NewInt(1 << 2)
)

type DecisionLogResponse struct {
	// Array of decision log entries (omitted when count=true).
	Data []*DecisionLog `json:"data,omitempty" url:"data,omitempty"`
	// Pagination cursor for fetching the next page. Null if no more results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Total count of matching logs (only present when count=true parameter is used).
	Count *int `json:"count,omitempty" url:"count,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DecisionLogResponse) GetData() []*DecisionLog {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DecisionLogResponse) GetCursor() *string {
	if d == nil {
		return nil
	}
	return d.Cursor
}

func (d *DecisionLogResponse) GetCount() *int {
	if d == nil {
		return nil
	}
	return d.Count
}

func (d *DecisionLogResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DecisionLogResponse) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DecisionLogResponse) SetData(data []*DecisionLog) {
	d.Data = data
	d.require(decisionLogResponseFieldData)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DecisionLogResponse) SetCursor(cursor *string) {
	d.Cursor = cursor
	d.require(decisionLogResponseFieldCursor)
}

// SetCount sets the Count field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DecisionLogResponse) SetCount(count *int) {
	d.Count = count
	d.require(decisionLogResponseFieldCount)
}

func (d *DecisionLogResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DecisionLogResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DecisionLogResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DecisionLogResponse) MarshalJSON() ([]byte, error) {
	type embed DecisionLogResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DecisionLogResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type QueryDecisionsRequestCount string

const (
	QueryDecisionsRequestCountTrue  QueryDecisionsRequestCount = "true"
	QueryDecisionsRequestCountFalse QueryDecisionsRequestCount = "false"
)

func NewQueryDecisionsRequestCountFromString(s string) (QueryDecisionsRequestCount, error) {
	switch s {
	case "true":
		return QueryDecisionsRequestCountTrue, nil
	case "false":
		return QueryDecisionsRequestCountFalse, nil
	}
	var t QueryDecisionsRequestCount
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (q QueryDecisionsRequestCount) Ptr() *QueryDecisionsRequestCount {
	return &q
}
