// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"
	internal "sdk/internal"
	time "time"
)

var (
	deleteValuesRequestFieldID = big.NewInt(1 << 0)
)

type DeleteValuesRequest struct {
	// ID of the dynamic value to delete
	ID string `json:"-" url:"id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (d *DeleteValuesRequest) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteValuesRequest) SetID(id string) {
	d.ID = id
	d.require(deleteValuesRequestFieldID)
}

var (
	listValuesRequestFieldName    = big.NewInt(1 << 0)
	listValuesRequestFieldInclude = big.NewInt(1 << 1)
)

type ListValuesRequest struct {
	// Query all dynamic values containing a specific name
	Name *string `json:"-" url:"name,omitempty"`
	// Comma-separated list of additional data to include. Use 'usage' to include which rules reference each value.
	Include *string `json:"-" url:"include,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (l *ListValuesRequest) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListValuesRequest) SetName(name *string) {
	l.Name = name
	l.require(listValuesRequestFieldName)
}

// SetInclude sets the Include field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListValuesRequest) SetInclude(include *string) {
	l.Include = include
	l.require(listValuesRequestFieldInclude)
}

var (
	dynamicValueFieldID         = big.NewInt(1 << 0)
	dynamicValueFieldName       = big.NewInt(1 << 1)
	dynamicValueFieldType       = big.NewInt(1 << 2)
	dynamicValueFieldValue      = big.NewInt(1 << 3)
	dynamicValueFieldUsages     = big.NewInt(1 << 4)
	dynamicValueFieldUserGroups = big.NewInt(1 << 5)
)

type DynamicValue struct {
	// Unique identifier for the dynamic value.
	ID string `json:"id" url:"id"`
	// Name of the dynamic value (may include dot notation for nested properties).
	Name string `json:"name" url:"name"`
	// Type identifier for the value (e.g., 'string', 'number', 'boolean', 'list', 'function', etc.)
	Type string `json:"type" url:"type"`
	// The actual value - can be any valid JSON type
	Value *DynamicValueValue `json:"value,omitempty" url:"value,omitempty"`
	// Rules that use this dynamic value (only included when 'include=usage' parameter is used).
	Usages []*RuleUsage `json:"usages,omitempty" url:"usages,omitempty"`
	// User groups assigned to this value.
	UserGroups []string `json:"user_groups,omitempty" url:"user_groups,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DynamicValue) GetID() string {
	if d == nil {
		return ""
	}
	return d.ID
}

func (d *DynamicValue) GetName() string {
	if d == nil {
		return ""
	}
	return d.Name
}

func (d *DynamicValue) GetType() string {
	if d == nil {
		return ""
	}
	return d.Type
}

func (d *DynamicValue) GetValue() *DynamicValueValue {
	if d == nil {
		return nil
	}
	return d.Value
}

func (d *DynamicValue) GetUsages() []*RuleUsage {
	if d == nil {
		return nil
	}
	return d.Usages
}

func (d *DynamicValue) GetUserGroups() []string {
	if d == nil {
		return nil
	}
	return d.UserGroups
}

func (d *DynamicValue) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DynamicValue) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicValue) SetID(id string) {
	d.ID = id
	d.require(dynamicValueFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicValue) SetName(name string) {
	d.Name = name
	d.require(dynamicValueFieldName)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicValue) SetType(type_ string) {
	d.Type = type_
	d.require(dynamicValueFieldType)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicValue) SetValue(value *DynamicValueValue) {
	d.Value = value
	d.require(dynamicValueFieldValue)
}

// SetUsages sets the Usages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicValue) SetUsages(usages []*RuleUsage) {
	d.Usages = usages
	d.require(dynamicValueFieldUsages)
}

// SetUserGroups sets the UserGroups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicValue) SetUserGroups(userGroups []string) {
	d.UserGroups = userGroups
	d.require(dynamicValueFieldUserGroups)
}

func (d *DynamicValue) UnmarshalJSON(data []byte) error {
	type unmarshaler DynamicValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DynamicValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DynamicValue) MarshalJSON() ([]byte, error) {
	type embed DynamicValue
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DynamicValue) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DynamicValueListResponse = []*DynamicValue

// The actual value - can be any valid JSON type
type DynamicValueValue struct {
	String           string
	Double           float64
	Boolean          bool
	UnknownList      []interface{}
	StringUnknownMap map[string]interface{}

	typ string
}

func (d *DynamicValueValue) GetString() string {
	if d == nil {
		return ""
	}
	return d.String
}

func (d *DynamicValueValue) GetDouble() float64 {
	if d == nil {
		return 0
	}
	return d.Double
}

func (d *DynamicValueValue) GetBoolean() bool {
	if d == nil {
		return false
	}
	return d.Boolean
}

func (d *DynamicValueValue) GetUnknownList() []interface{} {
	if d == nil {
		return nil
	}
	return d.UnknownList
}

func (d *DynamicValueValue) GetStringUnknownMap() map[string]interface{} {
	if d == nil {
		return nil
	}
	return d.StringUnknownMap
}

func (d *DynamicValueValue) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		d.typ = "String"
		d.String = valueString
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		d.typ = "Double"
		d.Double = valueDouble
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		d.typ = "Boolean"
		d.Boolean = valueBoolean
		return nil
	}
	var valueUnknownList []interface{}
	if err := json.Unmarshal(data, &valueUnknownList); err == nil {
		d.typ = "UnknownList"
		d.UnknownList = valueUnknownList
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		d.typ = "StringUnknownMap"
		d.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, d)
}

func (d DynamicValueValue) MarshalJSON() ([]byte, error) {
	if d.typ == "String" || d.String != "" {
		return json.Marshal(d.String)
	}
	if d.typ == "Double" || d.Double != 0 {
		return json.Marshal(d.Double)
	}
	if d.typ == "Boolean" || d.Boolean != false {
		return json.Marshal(d.Boolean)
	}
	if d.typ == "UnknownList" || d.UnknownList != nil {
		return json.Marshal(d.UnknownList)
	}
	if d.typ == "StringUnknownMap" || d.StringUnknownMap != nil {
		return json.Marshal(d.StringUnknownMap)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", d)
}

type DynamicValueValueVisitor interface {
	VisitString(string) error
	VisitDouble(float64) error
	VisitBoolean(bool) error
	VisitUnknownList([]interface{}) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (d *DynamicValueValue) Accept(visitor DynamicValueValueVisitor) error {
	if d.typ == "String" || d.String != "" {
		return visitor.VisitString(d.String)
	}
	if d.typ == "Double" || d.Double != 0 {
		return visitor.VisitDouble(d.Double)
	}
	if d.typ == "Boolean" || d.Boolean != false {
		return visitor.VisitBoolean(d.Boolean)
	}
	if d.typ == "UnknownList" || d.UnknownList != nil {
		return visitor.VisitUnknownList(d.UnknownList)
	}
	if d.typ == "StringUnknownMap" || d.StringUnknownMap != nil {
		return visitor.VisitStringUnknownMap(d.StringUnknownMap)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", d)
}

var (
	ruleUsageFieldID          = big.NewInt(1 << 0)
	ruleUsageFieldName        = big.NewInt(1 << 1)
	ruleUsageFieldDescription = big.NewInt(1 << 2)
	ruleUsageFieldSlug        = big.NewInt(1 << 3)
	ruleUsageFieldPublished   = big.NewInt(1 << 4)
	ruleUsageFieldUpdatedAt   = big.NewInt(1 << 5)
)

type RuleUsage struct {
	// The unique identifier for the rule.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the rule.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The description of the rule.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The unique slug for the rule used in API requests.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// Whether the rule is published.
	Published *bool `json:"published,omitempty" url:"published,omitempty"`
	// The date this rule was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RuleUsage) GetID() *string {
	if r == nil {
		return nil
	}
	return r.ID
}

func (r *RuleUsage) GetName() *string {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *RuleUsage) GetDescription() *string {
	if r == nil {
		return nil
	}
	return r.Description
}

func (r *RuleUsage) GetSlug() *string {
	if r == nil {
		return nil
	}
	return r.Slug
}

func (r *RuleUsage) GetPublished() *bool {
	if r == nil {
		return nil
	}
	return r.Published
}

func (r *RuleUsage) GetUpdatedAt() *time.Time {
	if r == nil {
		return nil
	}
	return r.UpdatedAt
}

func (r *RuleUsage) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RuleUsage) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleUsage) SetID(id *string) {
	r.ID = id
	r.require(ruleUsageFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleUsage) SetName(name *string) {
	r.Name = name
	r.require(ruleUsageFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleUsage) SetDescription(description *string) {
	r.Description = description
	r.require(ruleUsageFieldDescription)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleUsage) SetSlug(slug *string) {
	r.Slug = slug
	r.require(ruleUsageFieldSlug)
}

// SetPublished sets the Published field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleUsage) SetPublished(published *bool) {
	r.Published = published
	r.require(ruleUsageFieldPublished)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleUsage) SetUpdatedAt(updatedAt *time.Time) {
	r.UpdatedAt = updatedAt
	r.require(ruleUsageFieldUpdatedAt)
}

func (r *RuleUsage) UnmarshalJSON(data []byte) error {
	type embed RuleUsage
	var unmarshaler = struct {
		embed
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RuleUsage(unmarshaler.embed)
	r.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RuleUsage) MarshalJSON() ([]byte, error) {
	type embed RuleUsage
	var marshaler = struct {
		embed
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*r),
		UpdatedAt: internal.NewOptionalDateTime(r.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RuleUsage) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	updateValuesRequestFieldValues     = big.NewInt(1 << 0)
	updateValuesRequestFieldUserGroups = big.NewInt(1 << 1)
)

type UpdateValuesRequest struct {
	// A dictionary of keys and values to update or add. Supports both flat key-value pairs and nested objects. Nested objects will be automatically flattened using dot notation with readable key names (e.g., 'user.contact_info.email' becomes 'User.Contact Info.Email').
	Values map[string]interface{} `json:"values,omitempty" url:"-"`
	// Optional array of access group names or IDs. If omitted and user belongs to access groups, values will be assigned to all user's access groups. Required if values should be restricted to specific access groups.
	UserGroups []string `json:"user_groups,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (u *UpdateValuesRequest) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetValues sets the Values field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateValuesRequest) SetValues(values map[string]interface{}) {
	u.Values = values
	u.require(updateValuesRequestFieldValues)
}

// SetUserGroups sets the UserGroups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateValuesRequest) SetUserGroups(userGroups []string) {
	u.UserGroups = userGroups
	u.require(updateValuesRequestFieldUserGroups)
}
