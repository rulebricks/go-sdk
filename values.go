// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "sdk/core"
)

type DeleteDynamicValueRequest struct {
	// ID of the dynamic value to delete
	Id string `json:"-"`
}

type ListDynamicValuesRequest struct {
	// Name of a specific dynamic value to retrieve data for
	Name *string `json:"-"`
}

type DeleteDynamicValueResponse struct {
	// Confirmation message of successful deletion.
	Message *string `json:"message,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DeleteDynamicValueResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteDynamicValueResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteDynamicValueResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteDynamicValueResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type ListDynamicValuesResponseItem struct {
	// Unique identifier for the dynamic value.
	Id *string `json:"id,omitempty"`
	// Name of the dynamic value.
	Name *string `json:"name,omitempty"`
	// Data type of the dynamic value.
	Type *ListDynamicValuesResponseItemType `json:"type,omitempty"`
	// Value of the dynamic value.
	Value  *ListDynamicValuesResponseItemValue        `json:"value,omitempty"`
	Usages []*ListDynamicValuesResponseItemUsagesItem `json:"usages,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListDynamicValuesResponseItem) UnmarshalJSON(data []byte) error {
	type unmarshaler ListDynamicValuesResponseItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListDynamicValuesResponseItem(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListDynamicValuesResponseItem) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Data type of the dynamic value.
type ListDynamicValuesResponseItemType string

const (
	ListDynamicValuesResponseItemTypeString  ListDynamicValuesResponseItemType = "string"
	ListDynamicValuesResponseItemTypeNumber  ListDynamicValuesResponseItemType = "number"
	ListDynamicValuesResponseItemTypeBoolean ListDynamicValuesResponseItemType = "boolean"
	ListDynamicValuesResponseItemTypeList    ListDynamicValuesResponseItemType = "list"
)

func NewListDynamicValuesResponseItemTypeFromString(s string) (ListDynamicValuesResponseItemType, error) {
	switch s {
	case "string":
		return ListDynamicValuesResponseItemTypeString, nil
	case "number":
		return ListDynamicValuesResponseItemTypeNumber, nil
	case "boolean":
		return ListDynamicValuesResponseItemTypeBoolean, nil
	case "list":
		return ListDynamicValuesResponseItemTypeList, nil
	}
	var t ListDynamicValuesResponseItemType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l ListDynamicValuesResponseItemType) Ptr() *ListDynamicValuesResponseItemType {
	return &l
}

type ListDynamicValuesResponseItemUsagesItem struct {
	// The unique identifier for the rule.
	Id *string `json:"id,omitempty"`
	// The name of the rule.
	Name *string `json:"name,omitempty"`
	// The description of the rule.
	Description *string `json:"description,omitempty"`
	// Whether the rule is published.
	Published *bool `json:"published,omitempty"`
	// The unique slug for the rule used in API requests.
	Slug *string `json:"slug,omitempty"`
	// The date this rule was last updated.
	UpdatedAt *string `json:"updated_at,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListDynamicValuesResponseItemUsagesItem) UnmarshalJSON(data []byte) error {
	type unmarshaler ListDynamicValuesResponseItemUsagesItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListDynamicValuesResponseItemUsagesItem(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListDynamicValuesResponseItemUsagesItem) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Value of the dynamic value.
type ListDynamicValuesResponseItemValue struct {
	typeName    string
	String      string
	Double      float64
	Boolean     bool
	UnknownList []interface{}
}

func NewListDynamicValuesResponseItemValueFromString(value string) *ListDynamicValuesResponseItemValue {
	return &ListDynamicValuesResponseItemValue{typeName: "string", String: value}
}

func NewListDynamicValuesResponseItemValueFromDouble(value float64) *ListDynamicValuesResponseItemValue {
	return &ListDynamicValuesResponseItemValue{typeName: "double", Double: value}
}

func NewListDynamicValuesResponseItemValueFromBoolean(value bool) *ListDynamicValuesResponseItemValue {
	return &ListDynamicValuesResponseItemValue{typeName: "boolean", Boolean: value}
}

func NewListDynamicValuesResponseItemValueFromUnknownList(value []interface{}) *ListDynamicValuesResponseItemValue {
	return &ListDynamicValuesResponseItemValue{typeName: "unknownList", UnknownList: value}
}

func (l *ListDynamicValuesResponseItemValue) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		l.typeName = "string"
		l.String = valueString
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		l.typeName = "double"
		l.Double = valueDouble
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		l.typeName = "boolean"
		l.Boolean = valueBoolean
		return nil
	}
	var valueUnknownList []interface{}
	if err := json.Unmarshal(data, &valueUnknownList); err == nil {
		l.typeName = "unknownList"
		l.UnknownList = valueUnknownList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, l)
}

func (l ListDynamicValuesResponseItemValue) MarshalJSON() ([]byte, error) {
	switch l.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "string":
		return json.Marshal(l.String)
	case "double":
		return json.Marshal(l.Double)
	case "boolean":
		return json.Marshal(l.Boolean)
	case "unknownList":
		return json.Marshal(l.UnknownList)
	}
}

type ListDynamicValuesResponseItemValueVisitor interface {
	VisitString(string) error
	VisitDouble(float64) error
	VisitBoolean(bool) error
	VisitUnknownList([]interface{}) error
}

func (l *ListDynamicValuesResponseItemValue) Accept(visitor ListDynamicValuesResponseItemValueVisitor) error {
	switch l.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", l.typeName, l)
	case "string":
		return visitor.VisitString(l.String)
	case "double":
		return visitor.VisitDouble(l.Double)
	case "boolean":
		return visitor.VisitBoolean(l.Boolean)
	case "unknownList":
		return visitor.VisitUnknownList(l.UnknownList)
	}
}

type UpdateRequestValue struct {
	typeName    string
	String      string
	Double      float64
	Boolean     bool
	UnknownList []interface{}
}

func NewUpdateRequestValueFromString(value string) *UpdateRequestValue {
	return &UpdateRequestValue{typeName: "string", String: value}
}

func NewUpdateRequestValueFromDouble(value float64) *UpdateRequestValue {
	return &UpdateRequestValue{typeName: "double", Double: value}
}

func NewUpdateRequestValueFromBoolean(value bool) *UpdateRequestValue {
	return &UpdateRequestValue{typeName: "boolean", Boolean: value}
}

func NewUpdateRequestValueFromUnknownList(value []interface{}) *UpdateRequestValue {
	return &UpdateRequestValue{typeName: "unknownList", UnknownList: value}
}

func (u *UpdateRequestValue) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.typeName = "string"
		u.String = valueString
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		u.typeName = "double"
		u.Double = valueDouble
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		u.typeName = "boolean"
		u.Boolean = valueBoolean
		return nil
	}
	var valueUnknownList []interface{}
	if err := json.Unmarshal(data, &valueUnknownList); err == nil {
		u.typeName = "unknownList"
		u.UnknownList = valueUnknownList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateRequestValue) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "string":
		return json.Marshal(u.String)
	case "double":
		return json.Marshal(u.Double)
	case "boolean":
		return json.Marshal(u.Boolean)
	case "unknownList":
		return json.Marshal(u.UnknownList)
	}
}

type UpdateRequestValueVisitor interface {
	VisitString(string) error
	VisitDouble(float64) error
	VisitBoolean(bool) error
	VisitUnknownList([]interface{}) error
}

func (u *UpdateRequestValue) Accept(visitor UpdateRequestValueVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "string":
		return visitor.VisitString(u.String)
	case "double":
		return visitor.VisitDouble(u.Double)
	case "boolean":
		return visitor.VisitBoolean(u.Boolean)
	case "unknownList":
		return visitor.VisitUnknownList(u.UnknownList)
	}
}

type UpdateResponseItem struct {
	// Unique identifier for the dynamic value.
	Id *string `json:"id,omitempty"`
	// Name of the dynamic value.
	Name *string `json:"name,omitempty"`
	// Data type of the dynamic value.
	Type *UpdateResponseItemType `json:"type,omitempty"`
	// Value of the dynamic value.
	Value *UpdateResponseItemValue `json:"value,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UpdateResponseItem) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateResponseItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateResponseItem(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateResponseItem) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Data type of the dynamic value.
type UpdateResponseItemType string

const (
	UpdateResponseItemTypeString  UpdateResponseItemType = "string"
	UpdateResponseItemTypeNumber  UpdateResponseItemType = "number"
	UpdateResponseItemTypeBoolean UpdateResponseItemType = "boolean"
	UpdateResponseItemTypeList    UpdateResponseItemType = "list"
)

func NewUpdateResponseItemTypeFromString(s string) (UpdateResponseItemType, error) {
	switch s {
	case "string":
		return UpdateResponseItemTypeString, nil
	case "number":
		return UpdateResponseItemTypeNumber, nil
	case "boolean":
		return UpdateResponseItemTypeBoolean, nil
	case "list":
		return UpdateResponseItemTypeList, nil
	}
	var t UpdateResponseItemType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UpdateResponseItemType) Ptr() *UpdateResponseItemType {
	return &u
}

// Value of the dynamic value.
type UpdateResponseItemValue struct {
	typeName    string
	String      string
	Double      float64
	Boolean     bool
	UnknownList []interface{}
}

func NewUpdateResponseItemValueFromString(value string) *UpdateResponseItemValue {
	return &UpdateResponseItemValue{typeName: "string", String: value}
}

func NewUpdateResponseItemValueFromDouble(value float64) *UpdateResponseItemValue {
	return &UpdateResponseItemValue{typeName: "double", Double: value}
}

func NewUpdateResponseItemValueFromBoolean(value bool) *UpdateResponseItemValue {
	return &UpdateResponseItemValue{typeName: "boolean", Boolean: value}
}

func NewUpdateResponseItemValueFromUnknownList(value []interface{}) *UpdateResponseItemValue {
	return &UpdateResponseItemValue{typeName: "unknownList", UnknownList: value}
}

func (u *UpdateResponseItemValue) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		u.typeName = "string"
		u.String = valueString
		return nil
	}
	var valueDouble float64
	if err := json.Unmarshal(data, &valueDouble); err == nil {
		u.typeName = "double"
		u.Double = valueDouble
		return nil
	}
	var valueBoolean bool
	if err := json.Unmarshal(data, &valueBoolean); err == nil {
		u.typeName = "boolean"
		u.Boolean = valueBoolean
		return nil
	}
	var valueUnknownList []interface{}
	if err := json.Unmarshal(data, &valueUnknownList); err == nil {
		u.typeName = "unknownList"
		u.UnknownList = valueUnknownList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, u)
}

func (u UpdateResponseItemValue) MarshalJSON() ([]byte, error) {
	switch u.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "string":
		return json.Marshal(u.String)
	case "double":
		return json.Marshal(u.Double)
	case "boolean":
		return json.Marshal(u.Boolean)
	case "unknownList":
		return json.Marshal(u.UnknownList)
	}
}

type UpdateResponseItemValueVisitor interface {
	VisitString(string) error
	VisitDouble(float64) error
	VisitBoolean(bool) error
	VisitUnknownList([]interface{}) error
}

func (u *UpdateResponseItemValue) Accept(visitor UpdateResponseItemValueVisitor) error {
	switch u.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", u.typeName, u)
	case "string":
		return visitor.VisitString(u.String)
	case "double":
		return visitor.VisitDouble(u.Double)
	case "boolean":
		return visitor.VisitBoolean(u.Boolean)
	case "unknownList":
		return visitor.VisitUnknownList(u.UnknownList)
	}
}
