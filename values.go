// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"
	internal "sdk/internal"
	time "time"
)

var (
	deleteValuesRequestFieldID = big.NewInt(1 << 0)
)

type DeleteValuesRequest struct {
	// ID of the dynamic value to delete
	ID string `json:"-" url:"id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (d *DeleteValuesRequest) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteValuesRequest) SetID(id string) {
	d.ID = id
	d.require(deleteValuesRequestFieldID)
}

var (
	listValuesRequestFieldName    = big.NewInt(1 << 0)
	listValuesRequestFieldInclude = big.NewInt(1 << 1)
)

type ListValuesRequest struct {
	// Query all dynamic values containing a specific name
	Name *string `json:"-" url:"name,omitempty"`
	// Comma-separated list of additional data to include. Use 'usage' to include which rules reference each value.
	Include *string `json:"-" url:"include,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (l *ListValuesRequest) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListValuesRequest) SetName(name *string) {
	l.Name = name
	l.require(listValuesRequestFieldName)
}

// SetInclude sets the Include field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListValuesRequest) SetInclude(include *string) {
	l.Include = include
	l.require(listValuesRequestFieldInclude)
}

var (
	dynamicValueFieldID           = big.NewInt(1 << 0)
	dynamicValueFieldName         = big.NewInt(1 << 1)
	dynamicValueFieldType         = big.NewInt(1 << 2)
	dynamicValueFieldValue        = big.NewInt(1 << 3)
	dynamicValueFieldUsages       = big.NewInt(1 << 4)
	dynamicValueFieldAccessGroups = big.NewInt(1 << 5)
)

type DynamicValue struct {
	// Unique identifier for the dynamic value.
	ID string `json:"id" url:"id"`
	// Name of the dynamic value (may include dot notation for nested properties).
	Name string `json:"name" url:"name"`
	// Type identifier for the value (e.g., 'string', 'number', 'boolean', 'list', 'function', etc.)
	Type string `json:"type" url:"type"`
	// The actual value - can be any valid JSON type
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`
	// Rules that use this dynamic value (only included when 'include=usage' parameter is used).
	Usages []*RuleUsage `json:"usages,omitempty" url:"usages,omitempty"`
	// Access groups assigned to this value.
	AccessGroups []string `json:"accessGroups,omitempty" url:"accessGroups,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DynamicValue) GetID() string {
	if d == nil {
		return ""
	}
	return d.ID
}

func (d *DynamicValue) GetName() string {
	if d == nil {
		return ""
	}
	return d.Name
}

func (d *DynamicValue) GetType() string {
	if d == nil {
		return ""
	}
	return d.Type
}

func (d *DynamicValue) GetValue() interface{} {
	if d == nil {
		return nil
	}
	return d.Value
}

func (d *DynamicValue) GetUsages() []*RuleUsage {
	if d == nil {
		return nil
	}
	return d.Usages
}

func (d *DynamicValue) GetAccessGroups() []string {
	if d == nil {
		return nil
	}
	return d.AccessGroups
}

func (d *DynamicValue) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DynamicValue) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicValue) SetID(id string) {
	d.ID = id
	d.require(dynamicValueFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicValue) SetName(name string) {
	d.Name = name
	d.require(dynamicValueFieldName)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicValue) SetType(type_ string) {
	d.Type = type_
	d.require(dynamicValueFieldType)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicValue) SetValue(value interface{}) {
	d.Value = value
	d.require(dynamicValueFieldValue)
}

// SetUsages sets the Usages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicValue) SetUsages(usages []*RuleUsage) {
	d.Usages = usages
	d.require(dynamicValueFieldUsages)
}

// SetAccessGroups sets the AccessGroups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DynamicValue) SetAccessGroups(accessGroups []string) {
	d.AccessGroups = accessGroups
	d.require(dynamicValueFieldAccessGroups)
}

func (d *DynamicValue) UnmarshalJSON(data []byte) error {
	type unmarshaler DynamicValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DynamicValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DynamicValue) MarshalJSON() ([]byte, error) {
	type embed DynamicValue
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DynamicValue) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DynamicValueListResponse = []*DynamicValue

var (
	ruleUsageFieldID          = big.NewInt(1 << 0)
	ruleUsageFieldName        = big.NewInt(1 << 1)
	ruleUsageFieldDescription = big.NewInt(1 << 2)
	ruleUsageFieldSlug        = big.NewInt(1 << 3)
	ruleUsageFieldPublished   = big.NewInt(1 << 4)
	ruleUsageFieldUpdatedAt   = big.NewInt(1 << 5)
)

type RuleUsage struct {
	// The unique identifier for the rule.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the rule.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The description of the rule.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The unique slug for the rule used in API requests.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// Whether the rule is published.
	Published *bool `json:"published,omitempty" url:"published,omitempty"`
	// The date this rule was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RuleUsage) GetID() *string {
	if r == nil {
		return nil
	}
	return r.ID
}

func (r *RuleUsage) GetName() *string {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *RuleUsage) GetDescription() *string {
	if r == nil {
		return nil
	}
	return r.Description
}

func (r *RuleUsage) GetSlug() *string {
	if r == nil {
		return nil
	}
	return r.Slug
}

func (r *RuleUsage) GetPublished() *bool {
	if r == nil {
		return nil
	}
	return r.Published
}

func (r *RuleUsage) GetUpdatedAt() *time.Time {
	if r == nil {
		return nil
	}
	return r.UpdatedAt
}

func (r *RuleUsage) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RuleUsage) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleUsage) SetID(id *string) {
	r.ID = id
	r.require(ruleUsageFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleUsage) SetName(name *string) {
	r.Name = name
	r.require(ruleUsageFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleUsage) SetDescription(description *string) {
	r.Description = description
	r.require(ruleUsageFieldDescription)
}

// SetSlug sets the Slug field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleUsage) SetSlug(slug *string) {
	r.Slug = slug
	r.require(ruleUsageFieldSlug)
}

// SetPublished sets the Published field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleUsage) SetPublished(published *bool) {
	r.Published = published
	r.require(ruleUsageFieldPublished)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RuleUsage) SetUpdatedAt(updatedAt *time.Time) {
	r.UpdatedAt = updatedAt
	r.require(ruleUsageFieldUpdatedAt)
}

func (r *RuleUsage) UnmarshalJSON(data []byte) error {
	type embed RuleUsage
	var unmarshaler = struct {
		embed
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RuleUsage(unmarshaler.embed)
	r.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RuleUsage) MarshalJSON() ([]byte, error) {
	type embed RuleUsage
	var marshaler = struct {
		embed
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*r),
		UpdatedAt: internal.NewOptionalDateTime(r.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RuleUsage) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	updateValuesRequestFieldValues       = big.NewInt(1 << 0)
	updateValuesRequestFieldAccessGroups = big.NewInt(1 << 1)
)

type UpdateValuesRequest struct {
	// A dictionary of keys and values to update or add. Supports both flat key-value pairs and nested objects. Nested objects will be automatically flattened using dot notation with readable key names (e.g., 'user.contact_info.email' becomes 'User.Contact Info.Email').
	Values map[string]interface{} `json:"values,omitempty" url:"-"`
	// Optional array of access group names or IDs. If omitted and user belongs to access groups, values will be assigned to all user's access groups. Required if values should be restricted to specific access groups.
	AccessGroups []string `json:"accessGroups,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (u *UpdateValuesRequest) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetValues sets the Values field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateValuesRequest) SetValues(values map[string]interface{}) {
	u.Values = values
	u.require(updateValuesRequestFieldValues)
}

// SetAccessGroups sets the AccessGroups field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateValuesRequest) SetAccessGroups(accessGroups []string) {
	u.AccessGroups = accessGroups
	u.require(updateValuesRequestFieldAccessGroups)
}
