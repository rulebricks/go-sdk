// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "sdk/internal"
	time "time"
)

type ValuesDeleteRequest struct {
	// ID of the dynamic value to delete
	Id string `json:"-" url:"id"`
}

type ValuesListRequest struct {
	// Query all dynamic values containing a specific name
	Name *string `json:"-" url:"name,omitempty"`
	// Comma-separated list of additional data to include. Use 'usage' to include which rules reference each value.
	Include *string `json:"-" url:"include,omitempty"`
}

type DynamicValue struct {
	// Unique identifier for the dynamic value.
	Id string `json:"id" url:"id"`
	// Name of the dynamic value (may include dot notation for nested properties).
	Name string `json:"name" url:"name"`
	// Type identifier for the value (e.g., 'string', 'number', 'boolean', 'list', 'function', etc.)
	Type  string      `json:"type" url:"type"`
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`
	// Rules that use this dynamic value (only included when 'include=usage' parameter is used).
	Usages []*RuleUsage `json:"usages,omitempty" url:"usages,omitempty"`
	// Access groups assigned to this value.
	AccessGroups []string `json:"accessGroups,omitempty" url:"accessGroups,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DynamicValue) GetId() string {
	if d == nil {
		return ""
	}
	return d.Id
}

func (d *DynamicValue) GetName() string {
	if d == nil {
		return ""
	}
	return d.Name
}

func (d *DynamicValue) GetType() string {
	if d == nil {
		return ""
	}
	return d.Type
}

func (d *DynamicValue) GetValue() interface{} {
	if d == nil {
		return nil
	}
	return d.Value
}

func (d *DynamicValue) GetUsages() []*RuleUsage {
	if d == nil {
		return nil
	}
	return d.Usages
}

func (d *DynamicValue) GetAccessGroups() []string {
	if d == nil {
		return nil
	}
	return d.AccessGroups
}

func (d *DynamicValue) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DynamicValue) UnmarshalJSON(data []byte) error {
	type unmarshaler DynamicValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DynamicValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DynamicValue) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DynamicValueListResponse = []*DynamicValue

type RuleUsage struct {
	// The unique identifier for the rule.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the rule.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The description of the rule.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The unique slug for the rule used in API requests.
	Slug *string `json:"slug,omitempty" url:"slug,omitempty"`
	// Whether the rule is published.
	Published *bool `json:"published,omitempty" url:"published,omitempty"`
	// The date this rule was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RuleUsage) GetId() *string {
	if r == nil {
		return nil
	}
	return r.Id
}

func (r *RuleUsage) GetName() *string {
	if r == nil {
		return nil
	}
	return r.Name
}

func (r *RuleUsage) GetDescription() *string {
	if r == nil {
		return nil
	}
	return r.Description
}

func (r *RuleUsage) GetSlug() *string {
	if r == nil {
		return nil
	}
	return r.Slug
}

func (r *RuleUsage) GetPublished() *bool {
	if r == nil {
		return nil
	}
	return r.Published
}

func (r *RuleUsage) GetUpdatedAt() *time.Time {
	if r == nil {
		return nil
	}
	return r.UpdatedAt
}

func (r *RuleUsage) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RuleUsage) UnmarshalJSON(data []byte) error {
	type embed RuleUsage
	var unmarshaler = struct {
		embed
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RuleUsage(unmarshaler.embed)
	r.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RuleUsage) MarshalJSON() ([]byte, error) {
	type embed RuleUsage
	var marshaler = struct {
		embed
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*r),
		UpdatedAt: internal.NewOptionalDateTime(r.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (r *RuleUsage) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type UpdateValuesRequest struct {
	// A dictionary of keys and values to update or add. Supports both flat key-value pairs and nested objects. Nested objects will be automatically flattened using dot notation with readable key names (e.g., 'user.contact_info.email' becomes 'User.Contact Info.Email').
	Values map[string]interface{} `json:"values,omitempty" url:"-"`
	// Optional array of access group names or IDs. If omitted and user belongs to access groups, values will be assigned to all user's access groups. Required if values should be restricted to specific access groups.
	AccessGroups []string `json:"accessGroups,omitempty" url:"-"`
}
